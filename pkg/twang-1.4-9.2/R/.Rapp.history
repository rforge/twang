means.table
?means.table
plot(mnps.AOD, plots = 3)
subset
collapsedUnw
Q
##require(twang); data(AOD); AOD$crimjust[198:202] <- NA; mnps.AOD <- mnps(treat ~ illact + crimjust + subprob + subdep + white, data = AOD, estimand = "ATT", stop.method = c("ks.max","es.max"), n.trees = 1000, treatATT = 'community')#
plot.mnps <- function(x,plots="optimize", pairwiseMax = TRUE, figureRows = 1, color = TRUE, subset = NULL, ...)#
{#
   # Creates diag.plot plots and sends to current device#
   # x:     ps object #
   # label: Label added to the plot titles#
#
   # extract the propensity scores and weights from the ps object#
   	if(is.null(subset)) subset <- 1:length(x$stopMethods)#
   	ltBl <- ifelse(color, "lightblue","gray80")#
	rdCol <- ifelse(color, "red","black")#
	stripBgCol <- ifelse(color, "#ffe5cc", "transparent")#
	ptSymCol <- ifelse(color, "#0080ff", "black")#
   ifelse(x$estimand == "ATE", noKS <- TRUE, noKS <- FALSE)#
   subst <- whichVar <- pVal <- weighted <- NULL #
   if(length(plots) > 1) stop("The `plots' argument must be of length 1.")#
   if(!(plots %in% c(1,2,3,4,5)) & !(plots %in% c("boxplot","ks","optimize","es","t")))#
   stop("Invalid choice of `plots' argument.")#
   if(plots == 2 | plots == "boxplot"){#
   	boxplot(x, color = color, stop.method = subset, ...)#
   }#
   else{#
   if(!pairwiseMax | plots == "optimize" | plots == 1){#
   nPlot <- x$nFits#
   ptHld <- vector(mode = "list", length = nPlot)#
   for(i in 1:nPlot){#
   	if(x$estimand == "ATT") ptNm <- paste("Balance for", x$levExceptTreatATT[i], "versus unweighted", x$treatATT)#
   	else ptNm <- paste("Balance for", x$treatLev[i], "against others")#
   	ptHld[[i]] <- plot(x$psList[[i]], main = ptNm, plots = plots, noKS = TRUE, color = color, subset=subset, ...)#
   }#
#
#pt1 <- twang:::diag.plot(x, plots, subset = subset, ...)#
figCol <- ceiling(nPlot/figureRows)#
#
if(dev.cur() == 1) dev.new()#
#
curCol <- curRow <- 1#
#
for(i in 1:(nPlot-1)){#
	print(ptHld[[i]], split = c(curCol,curRow,nx = figCol,ny = figureRows), more = TRUE)#
	if(curCol < figCol){#
		curCol <- curCol + 1#
	}#
	else {#
		curCol <- 1#
		curRow <- curRow + 1#
	}#
}#
#
print(ptHld[[nPlot]], split = c(curCol,curRow,nx = figCol,ny = figureRows), more = FALSE)#
#
}#
#
else{  ## if pairwiseMax and plots == something other than optimize#
#
n.tp <- length(x$psList[[1]]$desc)#
n.psFits <- length(x$psList)#
#   	return(esDat)   #
   if (plots == "es" || plots == 3)	{ ## es plot#
   	esDat <- makePlotDat(x$psList[[1]], whichPlot = 3, subsetStopMeth = subset)#
   	nVar <- length(makePlotDat(x$psList[[1]], whichPlot = 3, subsetStopMeth = 1, yOnly = TRUE, incUnw = FALSE)$pVal)#
   	effSzList <- effSzListUnw <- pValListUnw <- pValList <- matrix(NA, nrow = nVar, ncol = length(x$psList))#
   	pwc <- bal.table(x, collapse.to = "covariate")#
   	#if(x$estimand == "ATE"){#
   	#	pwc <- pairwiseComparison(x, collapse.to = "covariate")	#
   	#	}#
   	cnt <- 0#
   	for(k in subset){#
   		cnt <- cnt + 1#
   		#if(x$estimand == "ATT"){#
   		#for(j in 1:length(x$psList)){	#
			#x2 <- x$psList[[j]]#
			#effSzList[,j] <- makePlotDat(x2, whichPlot = 3, subsetStopMeth = k, yOnly = TRUE, incUnw = FALSE)$effectSize#
			#effSzListUnw[,j] <- makePlotDat(x2, whichPlot = 3, subsetStopMeth = 1, yOnly = TRUE, incUnw = TRUE)$effectSize[(nVar + 1):(2*nVar)]#
			#pValListUnw[,j] <- makePlotDat(x2, whichPlot = 3, subsetStopMeth = 1, yOnly = TRUE, incUnw = TRUE)$pVal[(nVar + 1):(2*nVar)]#
			#pValList[,j] <- makePlotDat(x2, whichPlot = 3, subsetStopMeth = k, yOnly = TRUE, incUnw = FALSE)$pVal	#
			#}#
			#effSzList <- abs(effSzList)#
			#effSzListUnw <- abs(effSzListUnw)#
			#collapsed <- apply(effSzList, 1, max)#
			#collapsedUnw <- apply(effSzListUnw, 1, max)#
			#collapsedP <- apply(pValList < .05, 1, max)#
			#collapsedUnwP <- apply(pValListUnw < .05, 1, max)	#
			collapsed <- pwc$max.std.eff.sz[pwc$stop.method == x$stopMethods[k]]#
   			collapsedP <- pwc$min.p[pwc$stop.method == x$stopMethods[k]] < .05#
#   			collapsedUnw <- rep(pwc$max.std.eff.sz[pwc$stop.method == "unw"], length(subset))#
#   			collapsedUnwP <- rep(pwc$min.p[pwc$stop.method == "unw"], length(subset)) < .05		#
   			collapsedUnw <- rep(pwc$max.std.eff.sz[pwc$stop.method == "unw"], length(subset))#
   			collapsedUnwP <- rep(pwc$min.p[pwc$stop.method == "unw"], length(subset)) < .05		#
		#}#
		esBigHold <- collapsed > collapsedUnw#
		esDat$effectSize[(1:(2*nVar)) + (cnt-1)*2*nVar] <- c(collapsed, collapsedUnw)#
		esDat$pVal[(1:(2*nVar)) + (cnt-1)*2*nVar] <- c(collapsedP, collapsedUnwP)#
		esDat$esBig[(1:(2*nVar)) + (cnt-1)*2*nVar] <- rep(esBigHold, 2)#
	}#
   	yMax <- min(3,max(esDat[,1])) + .05	#
   	if(max(esDat[,1], na.rm=TRUE) > 3)#
   	warning("Some effect sizes are larger than 3 and may not have been plotted.\n")	#
    nullPlot <- TRUE#
   	subsetHold <- !esDat$esBig #
   	if(any(subsetHold)){#
   		esDatTmp <- esDat#
   		esDatTmp$effectSize[!subsetHold] <- NA#
   		pt1.1 <- xyplot(effectSize ~ weighted | whichComp, groups = whichVar, data = esDatTmp, scales = list(alternating = 1),#
   			ylim = c(-.05, yMax), type = "l", col = ltBl, as.table = TRUE,#
   			ylab = "Absolute standardized difference \n (maximum pairwise)", xlab = NULL, par.settings = list(strip.background = list(col=stripBgCol)),#
   			panel = function(...){#
   				panel.abline(h=c(.2,.5,.8), col="gray80")#
   				panel.xyplot(...)#
		   	})#
   		nullPlot <- FALSE#
   		currPt <- pt1.1#
   	}#
   	subsetHold <- esDat$esBig #
   	if(any(subsetHold)){#
   		esDatTmp <- esDat#
   		esDatTmp$effectSize[!subsetHold] <- NA#
   		pt1.2 <- xyplot(effectSize ~ weighted | whichComp, groups = whichVar, #
   			data = esDatTmp, ylab = "Absolute standard difference", xlab = NULL, as.table = TRUE,#
   			ylim = c(-.05, yMax), type = "l", col = rdCol, par.settings = list(strip.background = list(col=stripBgCol)),#
   			lwd = 2, ...)#
   		if(!nullPlot){#
   			currPt <- currPt + pt1.2#
   		}#
   		else{#
   			currPt <- pt1.2#
   			nullPlot <- FALSE#
   		}#
   	}#
   	if(all(esDat$pVal >= .05)) pchHold <- 19#
   	else if(all(esDat$pVal < .05)) pchHold <- 1#
   	else pchHold <- c(19,1)#
   	pt2 <- xyplot(effectSize ~ weighted | whichComp, groups = (pVal < 0.05), data = esDat,#
   	ylab = "Absolute standard difference", xlab = NULL, as.table = TRUE, #
   	ylim = c(-.05, yMax), type = "p", col = rdCol, pch = pchHold,par.settings = list(strip.background = list(col=stripBgCol)),#
   	...)#
   	if(!nullPlot) currPt <- currPt + pt2#
   	else currPt <- pt2#
   	return(currPt)#
   	}#
   if (plots == "t" || plots == 4) { ## t p-values plot#
#
   	esDat <- makePlotDat(x$psList[[1]], whichPlot = 4, subsetStopMeth = subset)#
   	nVar <- length(makePlotDat(x$psList[[1]], whichPlot = 4, subsetStopMeth = 1, yOnly = TRUE, incUnw = FALSE))#
   	effSzList <- effSzListUnw <- matrix(NA, nrow = nVar, ncol = length(x$psList))   	#
   	pwc <- bal.table(x, collapse.to = "covariate")#
   	cnt <- 0#
   	for(k in subset){#
   		cnt <- cnt + 1#
   	for(j in 1:length(x$psList)){	#
		collapsed <- pwc$min.p[pwc$stop.method == x$stopMethods[k]]	#
		collapsedUnw <- pwc$min.p[pwc$stop.method == 'unw']		#
		collRanks <- rank(collapsed, ties.method = "first")#
		esBigHold <- collapsed > collapsedUnw#
		esDat$tPVal[(1:(2*nVar)) + (cnt - 1)*2*nVar] <- c(collapsed, collapsedUnw)#
		esDat$tRank[(1:(2*nVar)) + (cnt - 1)*2*nVar] <- rep(collRanks, 2)#
	}#
	}#
   	   #	if(is.null(subst))	subst <- 1:length(levels(as.factor(esDat$whichComp)))#
   	n.var2 <- max(esDat$tRank * (!is.na(esDat$tPVal)), na.rm=TRUE)#
   	pt1 <- xyplot(tPVal~tRank|whichComp, groups = weighted, data=esDat, xlab = "Rank of p-value rank for pretreatment variables \n (hollow is weighted, solid is unweighted)", ylab = "t- and chi-squared p-values \n (pairwise minimum)", pch = c(19,1), col = "black", scales = list(alternating = 1), par.settings = list(strip.background = list(col=stripBgCol)),#
   	#subst = (as.factor(esDat$whichComp) %in% levels(as.factor(esDat$whichComp))[subst]) & (esDat$tRank <= n.var2), #
   	ylim = c(-.1, 1.1), ..., #
   	   	panel = function(...){#
   	   		panel.xyplot(x=c(1,n.var2), y=c(0,1), col=ltBl, type="l")#
#   		panel.abline(a=0, b=1, col="lightblue")#
   		panel.xyplot(...)#
   		}#
)#
   	}#
   if (plots =="ks" || plots ==5) {  ## ks plot#
   	if(x$estimand =="ATE") pwc <- pairwiseComparison(x, collapse.to = "covariate")#
#
   	esDat <- makePlotDat(x$psList[[1]], whichPlot = 5, subsetStopMeth = subset)#
   	nVar <- length(makePlotDat(x$psList[[1]], whichPlot = 5, subsetStopMeth = 1, yOnly = TRUE, incUnw = FALSE))#
   	effSzList <- effSzListUnw <- matrix(NA, nrow = nVar, ncol = length(x$psList))   	#
   	cnt <- 0#
   	for(k in subset){#
   		cnt <- cnt + 1#
   	for(j in 1:length(x$psList)){	#
	x2 <- x$psList[[j]]#
	effSzList[,j] <- makePlotDat(x2, whichPlot = 5, subsetStopMeth = k, yOnly = TRUE, incUnw = FALSE)#
	effSzListUnw[,j] <- makePlotDat(x2, whichPlot = 5, subsetStopMeth = 1, yOnly = TRUE, incUnw = TRUE)[1:nVar]#
	collapsed <- apply(effSzList, 1, max)#
	if(x$estimand == "ATE") collapsed <- pwc$min.ks.pval[pwc$stop.method == x$stopMethods[k]]#
	collapsedUnw <- apply(effSzListUnw, 1, max)#
	if(x$estimand == "ATE") collapsedUnw <- pwc$min.ks.pval[pwc$stop.method == "unw"]	#
	collRanks <- rank(collapsed, ties.method = "first")#
	esBigHold <- collapsed > collapsedUnw#
	esDat$ksPVal[(1:(2*nVar)) + (cnt-1)*2*nVar] <- c(collapsed, collapsedUnw)#
	esDat$ksRank[(1:(2*nVar)) + (cnt-1)*2*nVar] <- rep(collRanks, 2)#
	}#
	}#
   	if(is.null(subst))	subst <- 1:length(levels(as.factor(esDat$whichComp)))#
   	n.var2 <- max(esDat$ksRank*(!is.na(esDat$ksPVal)), na.rm=TRUE)#
   	pt1 <- xyplot(ksPVal~ksRank|whichComp, groups=weighted, scales = list(alternating = 1), data = esDat,ylim = c(-.1, 1.1), ..., xlab = "Rank of p-value rank for pretreatment variables \n (hollow is weighted, solid is unweighted)", ylab = "KS test p-values", pch = c(19,1), col="black",par.settings = list(strip.background = list(col=stripBgCol)),#
   	subst = (as.factor(esDat$whichComp) %in% levels(as.factor(esDat$whichComp))[subst]) & (esDat$ksRank <= n.var2),#
   	panel = function(...){#
   		panel.xyplot(x=c(1,n.var2), y=c(0,1), col=ltBl, type="l")#
   		panel.xyplot(...)#
   	})#
   	}#
return(pt1)#
	}#
#
}#
#
}
plot.mnps(mnps.AOD, plots = 3)
##require(twang); data(AOD); AOD$crimjust[198:202] <- NA; mnps.AOD <- mnps(treat ~ illact + crimjust + subprob + subdep + white, data = AOD, estimand = "ATT", stop.method = c("ks.max","es.max"), n.trees = 1000, treatATT = 'community')#
plot.mnps <- function(x,plots="optimize", pairwiseMax = TRUE, figureRows = 1, color = TRUE, subset = NULL, ...)#
{#
   # Creates diag.plot plots and sends to current device#
   # x:     ps object #
   # label: Label added to the plot titles#
#
   # extract the propensity scores and weights from the ps object#
   	if(is.null(subset)) subset <- 1:length(x$stopMethods)#
   	ltBl <- ifelse(color, "lightblue","gray80")#
	rdCol <- ifelse(color, "red","black")#
	stripBgCol <- ifelse(color, "#ffe5cc", "transparent")#
	ptSymCol <- ifelse(color, "#0080ff", "black")#
   ifelse(x$estimand == "ATE", noKS <- TRUE, noKS <- FALSE)#
   subst <- whichVar <- pVal <- weighted <- NULL #
   if(length(plots) > 1) stop("The `plots' argument must be of length 1.")#
   if(!(plots %in% c(1,2,3,4,5)) & !(plots %in% c("boxplot","ks","optimize","es","t")))#
   stop("Invalid choice of `plots' argument.")#
   if(plots == 2 | plots == "boxplot"){#
   	boxplot(x, color = color, stop.method = subset, ...)#
   }#
   else{#
   if(!pairwiseMax | plots == "optimize" | plots == 1){#
   nPlot <- x$nFits#
   ptHld <- vector(mode = "list", length = nPlot)#
   for(i in 1:nPlot){#
   	if(x$estimand == "ATT") ptNm <- paste("Balance for", x$levExceptTreatATT[i], "versus unweighted", x$treatATT)#
   	else ptNm <- paste("Balance for", x$treatLev[i], "against others")#
   	ptHld[[i]] <- plot(x$psList[[i]], main = ptNm, plots = plots, noKS = TRUE, color = color, subset=subset, ...)#
   }#
#
#pt1 <- twang:::diag.plot(x, plots, subset = subset, ...)#
figCol <- ceiling(nPlot/figureRows)#
#
if(dev.cur() == 1) dev.new()#
#
curCol <- curRow <- 1#
#
for(i in 1:(nPlot-1)){#
	print(ptHld[[i]], split = c(curCol,curRow,nx = figCol,ny = figureRows), more = TRUE)#
	if(curCol < figCol){#
		curCol <- curCol + 1#
	}#
	else {#
		curCol <- 1#
		curRow <- curRow + 1#
	}#
}#
#
print(ptHld[[nPlot]], split = c(curCol,curRow,nx = figCol,ny = figureRows), more = FALSE)#
#
}#
#
else{  ## if pairwiseMax and plots == something other than optimize#
#
n.tp <- length(x$psList[[1]]$desc)#
n.psFits <- length(x$psList)#
#   	return(esDat)   #
   if (plots == "es" || plots == 3)	{ ## es plot#
   	esDat <- makePlotDat(x$psList[[1]], whichPlot = 3, subsetStopMeth = subset)#
   	nVar <- length(makePlotDat(x$psList[[1]], whichPlot = 3, subsetStopMeth = 1, yOnly = TRUE, incUnw = FALSE)$pVal)#
   	effSzList <- effSzListUnw <- pValListUnw <- pValList <- matrix(NA, nrow = nVar, ncol = length(x$psList))#
   	pwc <- bal.table(x, collapse.to = "covariate")#
   	#if(x$estimand == "ATE"){#
   	#	pwc <- pairwiseComparison(x, collapse.to = "covariate")	#
   	#	}#
   	cnt <- 0#
   	for(k in subset){#
   		cnt <- cnt + 1#
   		#if(x$estimand == "ATT"){#
   		#for(j in 1:length(x$psList)){	#
			#x2 <- x$psList[[j]]#
			#effSzList[,j] <- makePlotDat(x2, whichPlot = 3, subsetStopMeth = k, yOnly = TRUE, incUnw = FALSE)$effectSize#
			#effSzListUnw[,j] <- makePlotDat(x2, whichPlot = 3, subsetStopMeth = 1, yOnly = TRUE, incUnw = TRUE)$effectSize[(nVar + 1):(2*nVar)]#
			#pValListUnw[,j] <- makePlotDat(x2, whichPlot = 3, subsetStopMeth = 1, yOnly = TRUE, incUnw = TRUE)$pVal[(nVar + 1):(2*nVar)]#
			#pValList[,j] <- makePlotDat(x2, whichPlot = 3, subsetStopMeth = k, yOnly = TRUE, incUnw = FALSE)$pVal	#
			#}#
			#effSzList <- abs(effSzList)#
			#effSzListUnw <- abs(effSzListUnw)#
			#collapsed <- apply(effSzList, 1, max)#
			#collapsedUnw <- apply(effSzListUnw, 1, max)#
			#collapsedP <- apply(pValList < .05, 1, max)#
			#collapsedUnwP <- apply(pValListUnw < .05, 1, max)	#
			collapsed <- pwc$max.std.eff.sz[pwc$stop.method == x$stopMethods[k]]#
   			collapsedP <- pwc$min.p[pwc$stop.method == x$stopMethods[k]] < .05#
#   			collapsedUnw <- rep(pwc$max.std.eff.sz[pwc$stop.method == "unw"], length(subset))#
#   			collapsedUnwP <- rep(pwc$min.p[pwc$stop.method == "unw"], length(subset)) < .05		#
   			collapsedUnw <- pwc$max.std.eff.sz[pwc$stop.method == "unw"]#
   			collapsedUnwP <- pwc$min.p[pwc$stop.method == "unw"] < .05		#
		#}#
		esBigHold <- collapsed > collapsedUnw#
		esDat$effectSize[(1:(2*nVar)) + (cnt-1)*2*nVar] <- c(collapsed, collapsedUnw)#
		esDat$pVal[(1:(2*nVar)) + (cnt-1)*2*nVar] <- c(collapsedP, collapsedUnwP)#
		esDat$esBig[(1:(2*nVar)) + (cnt-1)*2*nVar] <- rep(esBigHold, 2)#
	}#
   	yMax <- min(3,max(esDat[,1])) + .05	#
   	if(max(esDat[,1], na.rm=TRUE) > 3)#
   	warning("Some effect sizes are larger than 3 and may not have been plotted.\n")	#
    nullPlot <- TRUE#
   	subsetHold <- !esDat$esBig #
   	if(any(subsetHold)){#
   		esDatTmp <- esDat#
   		esDatTmp$effectSize[!subsetHold] <- NA#
   		pt1.1 <- xyplot(effectSize ~ weighted | whichComp, groups = whichVar, data = esDatTmp, scales = list(alternating = 1),#
   			ylim = c(-.05, yMax), type = "l", col = ltBl, as.table = TRUE,#
   			ylab = "Absolute standardized difference \n (maximum pairwise)", xlab = NULL, par.settings = list(strip.background = list(col=stripBgCol)),#
   			panel = function(...){#
   				panel.abline(h=c(.2,.5,.8), col="gray80")#
   				panel.xyplot(...)#
		   	})#
   		nullPlot <- FALSE#
   		currPt <- pt1.1#
   	}#
   	subsetHold <- esDat$esBig #
   	if(any(subsetHold)){#
   		esDatTmp <- esDat#
   		esDatTmp$effectSize[!subsetHold] <- NA#
   		pt1.2 <- xyplot(effectSize ~ weighted | whichComp, groups = whichVar, #
   			data = esDatTmp, ylab = "Absolute standard difference", xlab = NULL, as.table = TRUE,#
   			ylim = c(-.05, yMax), type = "l", col = rdCol, par.settings = list(strip.background = list(col=stripBgCol)),#
   			lwd = 2, ...)#
   		if(!nullPlot){#
   			currPt <- currPt + pt1.2#
   		}#
   		else{#
   			currPt <- pt1.2#
   			nullPlot <- FALSE#
   		}#
   	}#
   	if(all(esDat$pVal >= .05)) pchHold <- 19#
   	else if(all(esDat$pVal < .05)) pchHold <- 1#
   	else pchHold <- c(19,1)#
   	pt2 <- xyplot(effectSize ~ weighted | whichComp, groups = (pVal < 0.05), data = esDat,#
   	ylab = "Absolute standard difference", xlab = NULL, as.table = TRUE, #
   	ylim = c(-.05, yMax), type = "p", col = rdCol, pch = pchHold,par.settings = list(strip.background = list(col=stripBgCol)),#
   	...)#
   	if(!nullPlot) currPt <- currPt + pt2#
   	else currPt <- pt2#
   	return(currPt)#
   	}#
   if (plots == "t" || plots == 4) { ## t p-values plot#
#
   	esDat <- makePlotDat(x$psList[[1]], whichPlot = 4, subsetStopMeth = subset)#
   	nVar <- length(makePlotDat(x$psList[[1]], whichPlot = 4, subsetStopMeth = 1, yOnly = TRUE, incUnw = FALSE))#
   	effSzList <- effSzListUnw <- matrix(NA, nrow = nVar, ncol = length(x$psList))   	#
   	pwc <- bal.table(x, collapse.to = "covariate")#
   	cnt <- 0#
   	for(k in subset){#
   		cnt <- cnt + 1#
   	for(j in 1:length(x$psList)){	#
		collapsed <- pwc$min.p[pwc$stop.method == x$stopMethods[k]]	#
		collapsedUnw <- pwc$min.p[pwc$stop.method == 'unw']		#
		collRanks <- rank(collapsed, ties.method = "first")#
		esBigHold <- collapsed > collapsedUnw#
		esDat$tPVal[(1:(2*nVar)) + (cnt - 1)*2*nVar] <- c(collapsed, collapsedUnw)#
		esDat$tRank[(1:(2*nVar)) + (cnt - 1)*2*nVar] <- rep(collRanks, 2)#
	}#
	}#
   	   #	if(is.null(subst))	subst <- 1:length(levels(as.factor(esDat$whichComp)))#
   	n.var2 <- max(esDat$tRank * (!is.na(esDat$tPVal)), na.rm=TRUE)#
   	pt1 <- xyplot(tPVal~tRank|whichComp, groups = weighted, data=esDat, xlab = "Rank of p-value rank for pretreatment variables \n (hollow is weighted, solid is unweighted)", ylab = "t- and chi-squared p-values \n (pairwise minimum)", pch = c(19,1), col = "black", scales = list(alternating = 1), par.settings = list(strip.background = list(col=stripBgCol)),#
   	#subst = (as.factor(esDat$whichComp) %in% levels(as.factor(esDat$whichComp))[subst]) & (esDat$tRank <= n.var2), #
   	ylim = c(-.1, 1.1), ..., #
   	   	panel = function(...){#
   	   		panel.xyplot(x=c(1,n.var2), y=c(0,1), col=ltBl, type="l")#
#   		panel.abline(a=0, b=1, col="lightblue")#
   		panel.xyplot(...)#
   		}#
)#
   	}#
   if (plots =="ks" || plots ==5) {  ## ks plot#
   	if(x$estimand =="ATE") pwc <- pairwiseComparison(x, collapse.to = "covariate")#
#
   	esDat <- makePlotDat(x$psList[[1]], whichPlot = 5, subsetStopMeth = subset)#
   	nVar <- length(makePlotDat(x$psList[[1]], whichPlot = 5, subsetStopMeth = 1, yOnly = TRUE, incUnw = FALSE))#
   	effSzList <- effSzListUnw <- matrix(NA, nrow = nVar, ncol = length(x$psList))   	#
   	cnt <- 0#
   	for(k in subset){#
   		cnt <- cnt + 1#
   	for(j in 1:length(x$psList)){	#
	x2 <- x$psList[[j]]#
	effSzList[,j] <- makePlotDat(x2, whichPlot = 5, subsetStopMeth = k, yOnly = TRUE, incUnw = FALSE)#
	effSzListUnw[,j] <- makePlotDat(x2, whichPlot = 5, subsetStopMeth = 1, yOnly = TRUE, incUnw = TRUE)[1:nVar]#
	collapsed <- apply(effSzList, 1, max)#
	if(x$estimand == "ATE") collapsed <- pwc$min.ks.pval[pwc$stop.method == x$stopMethods[k]]#
	collapsedUnw <- apply(effSzListUnw, 1, max)#
	if(x$estimand == "ATE") collapsedUnw <- pwc$min.ks.pval[pwc$stop.method == "unw"]	#
	collRanks <- rank(collapsed, ties.method = "first")#
	esBigHold <- collapsed > collapsedUnw#
	esDat$ksPVal[(1:(2*nVar)) + (cnt-1)*2*nVar] <- c(collapsed, collapsedUnw)#
	esDat$ksRank[(1:(2*nVar)) + (cnt-1)*2*nVar] <- rep(collRanks, 2)#
	}#
	}#
   	if(is.null(subst))	subst <- 1:length(levels(as.factor(esDat$whichComp)))#
   	n.var2 <- max(esDat$ksRank*(!is.na(esDat$ksPVal)), na.rm=TRUE)#
   	pt1 <- xyplot(ksPVal~ksRank|whichComp, groups=weighted, scales = list(alternating = 1), data = esDat,ylim = c(-.1, 1.1), ..., xlab = "Rank of p-value rank for pretreatment variables \n (hollow is weighted, solid is unweighted)", ylab = "KS test p-values", pch = c(19,1), col="black",par.settings = list(strip.background = list(col=stripBgCol)),#
   	subst = (as.factor(esDat$whichComp) %in% levels(as.factor(esDat$whichComp))[subst]) & (esDat$ksRank <= n.var2),#
   	panel = function(...){#
   		panel.xyplot(x=c(1,n.var2), y=c(0,1), col=ltBl, type="l")#
   		panel.xyplot(...)#
   	})#
   	}#
return(pt1)#
	}#
#
}#
#
}
plot.mnps(mnps.AOD, plots = 3)
q()
require(twang); data(AOD); AOD$crimjust[198:202] <- NA; mnps.AOD <- mnps(treat ~ illact + crimjust + subprob + subdep + white, data = AOD, estimand = "ATT", stop.method = c("ks.max","es.max"), n.trees = 1000, treatATT = 'community')
bal.table(mnps.AOD)
bal.table
summary.mnps
twang:::summary.mnps
ls()
pairwiseComp(mnps.AOD)
twang:::pairwiseComp(mnps.AOD)
summary(mnps.AOD)
require(twang); data(AOD); AOD$crimjust[198:202] <- NA; mnps.AOD.ATE <- mnps(treat ~ illact + crimjust + subprob + subdep + white, data = AOD, estimand = "ATE", stop.method = c("ks.max","es.max"), n.trees = 1000)
summary(mnps.AOD.ATE)
summary(mnps.AOD)
rm(list=ls())
q()
require(twang); data(AOD);
mnps.AOD <- mnps(treat ~ illact + crimjust + subprob + subdep + white, data = AOD, estimand = "ATT", stop.method = c("ks.max","es.max"), n.trees = 1000, treatATT = 'community')
summary(mnps.AOD)
str(summary(mnps.AOD))
mnps.AOD$summaryList[[1]]
summary(mnps.AOD)$summaryList[[1]]
summary(mnps.AOD)
str(mnps.AOD)
names(mnps.AOD)
summary(mnps.AOD$treatVar)
sum(mnps.AOD$treatVar == treatATT)
sum(mnps.AOD$treatVar == mnps.AODtreatATT)
sum(mnps.AOD$treatVar == mnps.AOD$treatATT)
str(summary(mnps.AOD))
mnps.AOD$summarList[[1]]
summary(mnps.AOD)$summaryList[[1]]
row.names(summary(mnps.AOD)$summaryList[[1]])
twang:::print.summary.mnps
q()
require(twang); data(AOD)
mnps.AOD <- mnps(treat ~ illact + crimjust + subprob + subdep + white, data = AOD, estimand = "ATT", stop.method = c("ks.max","es.max"), n.trees = 1000, treatATT = 'community')
bal.table(mnps.AOD)
debug(bal.table)
bal.table(mnps.AOD)
balTabList
subset.var
es.cutoff
ks.cutoff
p.cutoff
ks.p.cutoff
balTabList
require(foreign)
Q
rm(list=ls())
require(foreign)
dt <- read.dta("~/Desktop/EMID/partiallyOrderedAnalysis/stataApprop/sub09_analytic04012014.dta")
dt <- read.dta("~/Desktop/EMID/partiallyOrderedAnalysis/stataApprop/sub09_analytic04012014small.dta")
head(dt)
require(lme4)
install.packages("lme4")
chooseCRANmirror()
install.packages("lme4")
require(lme4)
head(dt)
table(dt$subconvener)
subDt <- subset(dt, subconvener == "Cornell")
head(subDt)
head(unique(subDt$clinicianID))
length(unique(subDt$clinicianID))
subDt <- subDt[order(subDt$clinicianID),]
head(subDt)
hldRes <- data.frame(clinID = sort(subDt$clinicianID), numOrders = NA)
head(hldRes)
hldRes <- data.frame(clinID = sort(unique(subDt$clinicianID)), numOrders = NA)
head(hldRes)
for(i in 1:nrow(hldRes)) numOrders[i] <- sum(subDt$clinId == hldRes[i])
for(i in 1:nrow(hldRes)) numOrders[i] <- sum(subDt$clinId == hldRes$clinID[i])
for(i in 1:nrow(hldRes)) hldRes$numOrders[i] <- sum(subDt$clinId == hldRes$clinID[i])
head(hldRes)
for(i in 1:nrow(hldRes)) hldRes$numOrders[i] <- sum(subDt$clinicianID == hldRes$clinID[i])
head(hldRes)
rm(list=ls())
load("/Users/burgette/Desktop/rbrvs/timeEsts04162014/sparcsPrunedAnalyticOneCode04162014-NoMissAneType.RData")
ls()
head(smallSpAny)
smallSpAny$proc1 <- as.character(smallSpAny$proc1)#
smallSpAny$proc1[smallSpAny$proc1 == "G0104"] <- "45330"#
smallSpAny$proc1[smallSpAny$proc1 == "G0105"] <- "45378"#
smallSpAny$proc1[smallSpAny$proc1 == "G0121"] <- "45378"#
smallSpAny$proc1[smallSpAny$proc1 == "G0268"] <- "69210"
smallSpAny$proc1 <- as.numeric(smallSpAny$proc1)
spc <- with(smallSpAny, data.frame(time = optime_mins, ane = as.numeric(anemeth %in% c("20","30")), inpt = 0, spcs = 1, hcpcs = proc1))
head(spcs)
head(spc)
allDt <- spc
masterList <- read.csv("~/Desktop/rbrvs/timeEsts09042014/surgical_master_list09042014.csv")
masterList <- subset(masterList, core == 1)
masterList$Median_Intra_Service_Time2014[is.na(masterList$Median_Intra_Service_Time2014)] <- masterList$Median_Intra_Service_Time2013[is.na(masterList$Median_Intra_Service_Time2014)]
times2012 <- read.csv("~/Desktop/rbrvs/timeEsts08212014/PhysTime_FR2012_Public.csv")
times2012 <- times2012[,c("HCPCS","IntraService2012")]
masterList <- merge(masterList, times2012, all.x=TRUE)
masterList$Median_Intra_Service_Time2014[is.na(masterList$Median_Intra_Service_Time2014)] <- masterList$IntraService2012[is.na(masterList$Median_Intra_Service_Time2014)]
masterSmall <- masterList[,c("HCPCS","l1","Median_Intra_Service_Time2014","core","flag_sedate")]
masterSmall$HCPCS <- as.character(masterSmall$HCPCS)
names(masterSmall)[1] <- "hcpcs"
rm(masterList)
ls()
head(masterSmall)
summarh(masterSmall$flag_sedate)
summary(masterSmall$flag_sedate)
allDt <- merge(allDt, masterSmall)
head(allDt)
118 * 1.01
allDt$time <- newSilber07312014(allDt$time)
newSilber07312014 <- function(t){#
#
x <- c(0, 30, 70, 36 * 60)#
#
y <- c(0, 30 * .5, 70 * .86667 - 18, 36 * 60 * .86667 - 18)#
return(approx(x=x,y=y, xout = t)$y)#
}
allDt$time <- newSilber07312014(allDt$time)
.91057 * 300
head(allDt)
require(lme4)
summary(allDt$core)
lmer(log(time) ~ log(Median_Intra_Service_Time2014) + ane * flag_sedate + (1|hcpcs), data = allDt)
ft1 <- lmer(log(time) ~ log(Median_Intra_Service_Time2014) + ane * flag_sedate + (1|hcpcs), data = allDt)
summary(ft1)
table(allDt$flag_sedate)
table(allDt$flag_sedate, allDt$ane)
ft1 <- lmer(log(time) ~ ane * flag_sedate + (1|hcpcs), data = allDt)
summary(ft1)
q()
require(twang); data(AOD)
mnps.AOD <- mnps(treat ~ illact + crimjust + subprob + subdep + white, data = AOD, estimand = "ATT", stop.method = c("ks.max","es.max"), n.trees = 1000, treatATT = 'community')
plot(mnps.AOD, plots = 3)
plot(mnps.AOD, plots = 3, pairwiseMax = FALSE)
mnps.AOD <- mnps(treat ~ illact + crimjust + subprob + subdep + white, data = AOD, estimand = "ATE", stop.method = c("ks.max","es.max"), n.trees = 1000, treatATT = 'community')
plot(mnps.AOD, plots = 3, pairwiseMax = FALSE)
plot(mnps.AOD, plots = 4, pairwiseMax = FALSE)
plot(mnps.AOD, plots = 5, pairwiseMax = FALSE)
debug(plot.mnps)
debug(twang:::plot.mnps)
plot(mnps.AOD, plots = 5, pairwiseMax = FALSE)
head(pairs)
head(plotTab)
Q
undebug(twang:::plot.mnps)
plot(mnps.AOD, plots = 2, pairwiseMax = FALSE)
length(NULL)
plot(mnps.AOD, plots = 4)
debug(twang:::plot.mnps)
plot(mnps.AOD, plots = 5, pairwiseMax = FALSE)
head(plotTab)
head(allDat)
allDat
Q
# Produces a summary table for ps object #
summary.ps <- function(object,...){#
      summary.tab <- NULL#
      typ <- NULL   #
      n.tp <- length(object$desc)#
      for(i.tp in 1:n.tp){#
         desc.temp <- object$desc[[i.tp]]#
         iter      <- desc.temp$n.trees#
         tp        <- names(object$desc)[i.tp]#
#
		summary.tab <- rbind(summary.tab,#
            with(desc.temp, c(n.treat,n.ctrl,ess.treat,#
                                       ess.ctrl,#
                                       max.es,#
                                       mean.es,#
                                       max.ks,#
                                       max.ks.p,#
                                       mean.ks,#
                                       iter)))#
                                       typ <- c(typ, tp)#
      }#
summary.tab <- matrix(summary.tab, nrow = n.tp)#
      rownames(summary.tab) <- typ#
      colnames(summary.tab) <- c("n.treat", "n.ctrl", "ess.treat", "ess.ctrl", "max.es", "mean.es", "max.ks", "max.ks.p","mean.ks","iter")#
      class(summary.tab) <- "summary.ps"#
      return(summary.tab)#
}
q()
# Produces a summary table for ps object #
summary.ps <- function(object,...){#
      summary.tab <- NULL#
      typ <- NULL   #
      n.tp <- length(object$desc)#
      for(i.tp in 1:n.tp){#
         desc.temp <- object$desc[[i.tp]]#
         iter      <- desc.temp$n.trees#
         tp        <- names(object$desc)[i.tp]#
#
		summary.tab <- rbind(summary.tab,#
            with(desc.temp, c(n.treat,n.ctrl,ess.treat,#
                                       ess.ctrl,#
                                       max.es,#
                                       mean.es,#
                                       max.ks,#
                                       max.ks.p,#
                                       mean.ks,#
                                       iter)))#
                                       typ <- c(typ, tp)#
      }#
summary.tab <- matrix(summary.tab, nrow = n.tp)#
      rownames(summary.tab) <- typ#
      colnames(summary.tab) <- c("n.treat", "n.ctrl", "ess.treat", "ess.ctrl", "max.es", "mean.es", "max.ks", "max.ks.p","mean.ks","iter")#
      class(summary.tab) <- "summary.ps"#
      return(summary.tab)#
}
detach("package:twang", unload = TRUE)
library(twang)
detach("package:twang", unload = TRUE)
library(twang)
require(twang); data(AOD); AOD$crimjust[198:202] <- NA; mnps.AOD <- mnps(treat ~ illact + crimjust + subprob + subdep + white, data = AOD, estimand = "ATT", stop.method = c("ks.max","es.max"), n.trees = 1000, treatATT = 'community')
plot(mnps.AOD, plots = 1)
plot(mnps.AOD, plots = 2)
plot(mnps.AOD, plots = 3)
plot(mnps.AOD, plots = 4)
plot(mnps.AOD, plots = 4, subset = 1)
plot(mnps.AOD, plots = 4, subset = 2)
plot(mnps.AOD, plots = 4, subset = 2, pairwiseMax = FALSE)
require(twang); data(AOD)
mnps.AOD <- mnps(treat ~ illact + crimjust + subprob + subdep + white, data = AOD, estimand = "ATT", stop.method = c("ks.max","es.max"), n.trees = 1000, treatATT = 'community')
mnps.AOD <- mnps(treat ~ illact + crimjust + subprob + subdep + white, data = AOD, estimand = "ATE", stop.method = c("ks.max","es.max"), n.trees = 1000, treatATT = 'community')
plot(mnps.AOD, plots = 3)
plot(mnps.AOD, plots = 3, pairwiseMax = FALSE)
plot(mnps.AOD, plots = 4, pairwiseMax = FALSE)
detach("package:twang", unload = TRUE)
require(twang)
plot(mnps.AOD, plots = 4, pairwiseMax = FALSE)
detach("package:twang", unload = TRUE)
require(twang)
plot(mnps.AOD, plots = 4, pairwiseMax = FALSE)
detach("package:twang", unload = TRUE)
require(twang)
plot(mnps.AOD, plots = 4, pairwiseMax = FALSE)
detach("package:twang", unload = TRUE)
require(twang)
plot(mnps.AOD, plots = 4, pairwiseMax = FALSE)
debug(twang:::plot.mnps)
plot(mnps.AOD, plots = 4, pairwiseMax = FALSE)
head(pairs)
unique(pairs$var)
summary(pairs$stop.method)
Q
detach("package:twang", unload = TRUE)
require(twang)
plot(mnps.AOD, plots = 4, pairwiseMax = FALSE)
detach("package:twang", unload = TRUE)
require(twang)
debug(twang:::plot.mnps)
plot(mnps.AOD, plots = 4, pairwiseMax = FALSE)
plotTab
ptNames
plotTab
collapsed
nVar
length(collapsed)
length(collapsedUnw)
plotTab
x$stopMethods
Q
detach("package:twang", unload = TRUE)
require(twang)
plot(mnps.AOD, plots = 4, pairwiseMax = FALSE)
debug(twang:::plot.mnps)
plot(mnps.AOD, plots = 4, pairwiseMax = FALSE)
nVar
n.var2
plotTab
plotTab
debug(twang:::plot.mnps)
detach("package:twang", unload = TRUE)
require(twang)
plot(mnps.AOD, plots = 4, pairwiseMax = FALSE)
debug(twang:::plot.mnps)
plot(mnps.AOD, plots = 4, pairwiseMax = FALSE)
stp
pairs
collapsedUnw
plotTab
Q
detach("package:twang", unload = TRUE)
require(twang)
plot(mnps.AOD, plots = 4, pairwiseMax = FALSE)
detach("package:twang", unload = TRUE)
require(twang)
plot(mnps.AOD, plots = 4, pairwiseMax = FALSE)
plot(mnps.AOD, plots = 5)
detach("package:twang", unload = TRUE)
plot(mnps.AOD, plots = 5, pairwiseMax = FALSE)
detach("package:twang", unload = TRUE)
require(twang)
plot(mnps.AOD, plots = 5, pairwiseMax = FALSE)
detach("package:twang", unload = TRUE)
require(twang)
plot(mnps.AOD, plots = 5, pairwiseMax = FALSE)
detach("package:twang", unload = TRUE)
plot(mnps.AOD, plots = 5, pairwiseMax = FALSE)
detach("package:twang", unload = TRUE)
require(twang)
plot(mnps.AOD, plots = 5, pairwiseMax = FALSE)
q()
