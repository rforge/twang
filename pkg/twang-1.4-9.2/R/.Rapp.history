plot(mnps.AOD)
plot.mnps
twang:::plot.mnps
plot(mnps.AOD$psList[[1]])
str(psList[[1]])
str(mnps.AOD$psList[[1]])
debug(mnps3)
mnps.AOD <- mnps3(treat ~ illact + crimjust + subprob + subdep + white, data = AOD, estimate = "AOD", estimand = "ATT", stop.method = "es.max", n.trees = 300, treatATT = "community")
pairwiseComp(wtVec = rep(1, nrow(data)), data = data, #
    treat.var = treat.var, vars = var.names, sampW = sampw, estimand = estimand, #
    compFcn = match.fun(compFcn), summaryFcn = match.fun(summaryFcn), #
    treatATT = treatATT)
Q
undebug(mnps3)
debug(twang:::pairwiseComp)
mnps.AOD <- mnps3(treat ~ illact + crimjust + subprob + subdep + white, data = AOD, estimate = "AOD", estimand = "ATT", stop.method = "es.max", n.trees = 300, treatATT = "community")
j
hldSE
summaryFcn
Q
q()
require(twang); data(AOD); mnps.AOD4 <- mnps(treat ~ illact + crimjust + subprob + subdep + white, data = AOD, estimate = "AOD", estimand = "ATT", stop.method = "es.max", n.trees = 1000, treatATT = "community")
get.weights(mnps.AOD, stop.method = "es.max")
get.weights(mnps.AOD4, stop.method = "es.max")
require(twang); data(AOD); mnps.AOD4 <- mnps(treat ~ illact + crimjust + subprob + subdep + white, data = AOD, estimate = "AOD", estimand = "ATT", stop.method = "es.mean", n.trees = 1000, treatATT = "community")
get.weights(mnps.AOD4, stop.method = "es.mean")
get.weights(mnps.AOD4, stop.method = "es.mean", estimand = "ATT")
get.weights(mnps.AOD4, stop.method = "es.mean", estimand = "ATE")
q()
require(twang); data(lalonde); ps.lalonde <- ps(treat~age + educ + black + hispan + nodegree + married + re74 + re75, data = lalonde, stop.method = "es.max",estimand = "ATT", n.trees = 5000, verbose = FALSE)
boxplot(ps.lalonde)
debug(twang:::boxplot.ps)
boxplot(ps.lalonde)
debug(boxplot)
boxplot(ps.lalonde)
twang:::boxplot.ps(ps.lalonde)
methods(boxplot)
q()
require(twang); data(AOD); mnps.AOD4 <- mnps(treat ~ illact + crimjust + subprob + subdep + white, data = AOD, estimand = "ATT", stop.method = "es.max", n.trees = 1000, treatATT = "community")
twang:::plot.mnps
debug(twang:::plot.mnps)
require(twang); data(AOD); mnps.AOD4 <- mnps(treat ~ illact + crimjust + subprob + subdep + white, data = AOD, estimand = "ATE", stop.method = "es.max", n.trees = 1000)
summary(mnps.AOD4)
plot(mnps.AOD4, plots = 4)
pwc
esDat
plot(mnps.AOD4, plots = 3)
print(pt1.1)
esDat
collapsedUnwP
plot(mnps.AOD4, plots = 3)
esDat
j
pwc
pValList
pValListUnw
plot(mnps.AOD4, plots = 3)
esDat
15000 * .0075
pairwiseComparison(x)
pairwiseComparison(x, collapse.to = "covariate")
13.6 +3
13.6 +3+3
length(2)
Q
undebug(plot.mnps)
undebug(twang:::plot.mnps)
##require(twang); data(AOD); AOD$crimjust[198:202] <- NA; mnps.AOD <- mnps(treat ~ illact + crimjust + subprob + subdep + white, data = AOD, estimand = "ATT", stop.method = c("ks.max","es.max"), n.trees = 1000, treatATT = 'community')#
plotUpdate.mnps <- function(x,plots="optimize", pairwiseMax = TRUE, figureRows = 1, color = TRUE, subset = NULL, ...)#
{#
   # Creates diag.plot plots and sends to current device#
   # x:     ps object #
   # label: Label added to the plot titles#
#
   # extract the propensity scores and weights from the ps object#
   	if(is.null(subset)) subset <- 1:length(x$stopMethods)#
   	ltBl <- ifelse(color, "lightblue","gray80")#
	rdCol <- ifelse(color, "red","black")#
	stripBgCol <- ifelse(color, "#ffe5cc", "transparent")#
	ptSymCol <- ifelse(color, "#0080ff", "black")#
   ifelse(x$estimand == "ATE", noKS <- TRUE, noKS <- FALSE)#
   subst <- whichVar <- pVal <- weighted <- NULL #
   if(length(plots) > 1) stop("The `plots' argument must be of length 1.")#
   if(!(plots %in% c(1,2,3,4,5)) & !(plots %in% c("boxplot","ks","optimize","es","t")))#
   stop("Invalid choice of `plots' argument.")#
   if(plots == 2 | plots == "boxplot"){#
   	boxplot(x, color = color, stop.method = subset, ...)#
   }#
   else{#
   if(!pairwiseMax | plots == "optimize" | plots == 1){#
   nPlot <- x$nFits#
   ptHld <- vector(mode = "list", length = nPlot)#
   for(i in 1:nPlot){#
   	if(x$estimand == "ATT") ptNm <- paste("Balance for", x$levExceptTreatATT[i], "versus unweighted", x$treatATT)#
   	else ptNm <- paste("Balance for", x$treatLev[i], "against others")#
   	ptHld[[i]] <- plot(x$psList[[i]], main = ptNm, plots = plots, noKS = TRUE, color = color, subset=subset, ...)#
   }#
#
#pt1 <- twang:::diag.plot(x, plots, subset = subset, ...)#
figCol <- ceiling(nPlot/figureRows)#
#
if(dev.cur() == 1) dev.new()#
#
curCol <- curRow <- 1#
#
for(i in 1:(nPlot-1)){#
	print(ptHld[[i]], split = c(curCol,curRow,nx = figCol,ny = figureRows), more = TRUE)#
	if(curCol < figCol){#
		curCol <- curCol + 1#
	}#
	else {#
		curCol <- 1#
		curRow <- curRow + 1#
	}#
}#
#
print(ptHld[[nPlot]], split = c(curCol,curRow,nx = figCol,ny = figureRows), more = FALSE)#
#
}#
#
else{  ## if pairwiseMax and plots == something other than optimize#
#
n.tp <- length(x$psList[[1]]$desc)#
n.psFits <- length(x$psList)#
#   	return(esDat)   #
   if (plots == "es" || plots == 3)	{ ## es plot#
   	esDat <- makePlotDat(x$psList[[1]], whichPlot = 3, subsetStopMeth = subset)#
   	nVar <- length(makePlotDat(x$psList[[1]], whichPlot = 3, subsetStopMeth = 1, yOnly = TRUE, incUnw = FALSE)$pVal)#
   	effSzList <- effSzListUnw <- pValListUnw <- pValList <- matrix(NA, nrow = nVar, ncol = length(x$psList))#
   	if(x$estimand == "ATE"){#
   		pwc <- pairwiseComparison(x, collapse.to = "covariate")#
   		}#
   		collapsed <- pwc$max.std.eff.sz[pwc$stop.method %in% x$stop.methods[subset]]#
   		collapsedP <- pwc$min.p[pwc$stop.method %in% x$stop.methods[subset]]#
   		collapsedUnw <- rep(pwc$max.std.eff.sz[pwc$stop.method == "unw"], length(subset))#
   		collapsedUnwP <- rep(pwc$min.p[pwc$stop.method == "unw"], length(subset))#
   	cnt <- 0#
   	for(k in subset){#
   		cnt <- cnt + 1#
   		if(x$estimand == "ATT"){#
   			for(j in 1:length(x$psList)){	#
				x2 <- x$psList[[j]]#
				effSzList[,j] <- makePlotDat(x2, whichPlot = 3, subsetStopMeth = k, yOnly = TRUE, incUnw = FALSE)$effectSize#
				effSzListUnw[,j] <- makePlotDat(x2, whichPlot = 3, subsetStopMeth = 1, yOnly = TRUE, incUnw = TRUE)$effectSize[(nVar + 1):(2*nVar)]#
				pValListUnw[,j] <- makePlotDat(x2, whichPlot = 3, subsetStopMeth = 1, yOnly = TRUE, incUnw = TRUE)$pVal[(nVar + 1):(2*nVar)]#
				pValList[,j] <- makePlotDat(x2, whichPlot = 3, subsetStopMeth = k, yOnly = TRUE, incUnw = FALSE)$pVal	#
			}#
			effSzList <- abs(effSzList)#
			effSzListUnw <- abs(effSzListUnw)#
			collapsed <- apply(effSzList, 1, max)#
			collapsedUnw <- apply(effSzListUnw, 1, max)#
			collapsedP <- apply(pValList < .05, 1, max)#
			collapsedUnwP <- apply(pValListUnw < .05, 1, max)			#
		}#
		#if(x$estimand == "ATE"){#
	   	#	collapsed <- pwc$max.std.eff.sz[pwc$stop.method == x$stop.methods[k]]#
   		#	collapsedP <- pwc$min.p[pwc$stop.method == x$stop.methods[subset]]#
   		#	collapsedUnw <- pwc$max.std.eff.sz[pwc$stop.method == "unw"] < .05#
   		#	collapsedUnwP <- pwc$min.p[pwc$stop.method == "unw"] < .05#
		#}#
		esBigHold <- collapsed > collapsedUnw#
		esDat$effectSize[(1:(2*nVar)) + (cnt-1)*2*nVar] <- c(collapsed, collapsedUnw)#
		esDat$pVal[(1:(2*nVar)) + (cnt-1)*2*nVar] <- c(collapsedP, collapsedUnwP)#
		esDat$esBig[(1:(2*nVar)) + (cnt-1)*2*nVar] <- rep(esBigHold, 2)#
	}#
   	yMax <- min(3,max(esDat[,1])) + .05	#
   	if(max(esDat[,1], na.rm=TRUE) > 3)#
   	warning("Some effect sizes are larger than 3 and may not have been plotted.\n")	#
    nullPlot <- TRUE#
   	subsetHold <- !esDat$esBig #
   	if(any(subsetHold)){#
   		esDatTmp <- esDat#
   		esDatTmp$effectSize[!subsetHold] <- NA#
   		pt1.1 <- xyplot(effectSize ~ weighted | whichComp, groups = whichVar, data = esDatTmp, scales = list(alternating = 1),#
   			ylim = c(-.05, yMax), type = "l", col = ltBl, as.table = TRUE,#
   			ylab = "Absolute standard difference", xlab = NULL, par.settings = list(strip.background = list(col=stripBgCol)),#
   			panel = function(...){#
   				panel.abline(h=c(.2,.5,.8), col="gray80")#
   				panel.xyplot(...)#
		   	})#
   		nullPlot <- FALSE#
   		currPt <- pt1.1#
   	}#
   	subsetHold <- esDat$esBig #
   	if(any(subsetHold)){#
   		esDatTmp <- esDat#
   		esDatTmp$effectSize[!subsetHold] <- NA#
   		pt1.2 <- xyplot(effectSize ~ weighted | whichComp, groups = whichVar, #
   			data = esDatTmp, ylab = "Absolute standard difference", xlab = NULL, as.table = TRUE,#
   			ylim = c(-.05, yMax), type = "l", col = rdCol, par.settings = list(strip.background = list(col=stripBgCol)),#
   			lwd = 2, ...)#
   		if(!nullPlot){#
   			currPt <- currPt + pt1.2#
   		}#
   		else{#
   			currPt <- pt1.2#
   			nullPlot <- FALSE#
   		}#
   	}#
   	if(all(esDat$pVal >= .05)) pchHold <- 19#
   	else if(all(esDat$pVal < .05)) pchHold <- 1#
   	else pchHold <- c(19,1)#
   	pt2 <- xyplot(effectSize ~ weighted | whichComp, groups = (pVal < 0.05), data = esDat,#
   	ylab = "Absolute standard difference", xlab = NULL, as.table = TRUE, #
   	ylim = c(-.05, yMax), type = "p", col = rdCol, pch = pchHold,par.settings = list(strip.background = list(col=stripBgCol)),#
   	...)#
   	if(!nullPlot) currPt <- currPt + pt2#
   	else currPt <- pt2#
   	return(currPt)#
   	}#
   if (plots == "t" || plots == 4) { ## t p-values plot#
#
   	esDat <- makePlotDat(x$psList[[1]], whichPlot = 4, subsetStopMeth = subset)#
   	nVar <- length(makePlotDat(x$psList[[1]], whichPlot = 4, subsetStopMeth = 1, yOnly = TRUE, incUnw = FALSE))#
   	effSzList <- effSzListUnw <- matrix(NA, nrow = nVar, ncol = length(x$psList))   	#
   	if(x$estimand =="ATE") pwc <- pairwiseComparison(x, collapse.to = "covariate")#
   	cnt <- 0#
   	for(k in subset){#
   		cnt <- cnt + 1#
   	for(j in 1:length(x$psList)){	#
	x2 <- x$psList[[j]]#
	effSzList[,j] <- makePlotDat(x2, whichPlot = 4, subsetStopMeth = k, yOnly = TRUE, incUnw = FALSE)#
	effSzListUnw[,j] <- makePlotDat(x2, whichPlot = 4, subsetStopMeth = 1, yOnly = TRUE, incUnw = TRUE)[1:nVar]#
	collapsed <- apply(-1 *effSzList, 1, max)#
	collapsed <- -1 * collapsed#
	if(x$estimand == "ATE") collapsed <- pwc$min.p[pwc$stop.method == x$stopMethods[k]]	#
	collapsedUnw <- apply(-1 * effSzListUnw, 1, max)#
	collapsedUnw <- -1 * collapsedUnw#
	if(x$estimand == "ATE") collapsedUnw <- pwc$min.p[pwc$stop.method == 'unw']		#
	collRanks <- rank(collapsed, ties.method = "first")#
	esBigHold <- collapsed > collapsedUnw#
	esDat$tPVal[(1:(2*nVar)) + (cnt - 1)*2*nVar] <- c(collapsed, collapsedUnw)#
	esDat$tRank[(1:(2*nVar)) + (cnt - 1)*2*nVar] <- rep(collRanks, 2)#
	}#
	}#
   	   #	if(is.null(subst))	subst <- 1:length(levels(as.factor(esDat$whichComp)))#
   	n.var2 <- max(esDat$tRank * (!is.na(esDat$tPVal)), na.rm=TRUE)#
   	pt1 <- xyplot(tPVal~tRank|whichComp, groups = weighted, data=esDat, xlab = "Rank of p-value rank for pretreatment variables \n (hollow is weighted, solid is unweighted)", ylab = "T test p-values", pch = c(19,1), col = "black", scales = list(alternating = 1), par.settings = list(strip.background = list(col=stripBgCol)),#
   	#subst = (as.factor(esDat$whichComp) %in% levels(as.factor(esDat$whichComp))[subst]) & (esDat$tRank <= n.var2), #
   	ylim = c(-.1, 1.1), ..., #
   	   	panel = function(...){#
   	   		panel.xyplot(x=c(1,n.var2), y=c(0,1), col=ltBl, type="l")#
#   		panel.abline(a=0, b=1, col="lightblue")#
   		panel.xyplot(...)#
   		}#
)#
   	}#
   if (plots =="ks" || plots ==5) {  ## ks plot#
   	if(x$estimand =="ATE") pwc <- pairwiseComparison(x, collapse.to = "covariate")#
#
   	esDat <- makePlotDat(x$psList[[1]], whichPlot = 5, subsetStopMeth = subset)#
   	nVar <- length(makePlotDat(x$psList[[1]], whichPlot = 5, subsetStopMeth = 1, yOnly = TRUE, incUnw = FALSE))#
   	effSzList <- effSzListUnw <- matrix(NA, nrow = nVar, ncol = length(x$psList))   	#
   	cnt <- 0#
   	for(k in subset){#
   		cnt <- cnt + 1#
   	for(j in 1:length(x$psList)){	#
	x2 <- x$psList[[j]]#
	effSzList[,j] <- makePlotDat(x2, whichPlot = 5, subsetStopMeth = k, yOnly = TRUE, incUnw = FALSE)#
	effSzListUnw[,j] <- makePlotDat(x2, whichPlot = 5, subsetStopMeth = 1, yOnly = TRUE, incUnw = TRUE)[1:nVar]#
	collapsed <- apply(effSzList, 1, max)#
	if(x$estimand == "ATE") collapsed <- pwc$min.ks.pval[pwc$stop.method == x$stopMethods[k]]#
	collapsedUnw <- apply(effSzListUnw, 1, max)#
	if(x$estimand == "ATE") collapsedUnw <- pwc$min.ks.pval[pwc$stop.method == "unw"]	#
	collRanks <- rank(collapsed, ties.method = "first")#
	esBigHold <- collapsed > collapsedUnw#
	esDat$ksPVal[(1:(2*nVar)) + (cnt-1)*2*nVar] <- c(collapsed, collapsedUnw)#
	esDat$ksRank[(1:(2*nVar)) + (cnt-1)*2*nVar] <- rep(collRanks, 2)#
	}#
	}#
   	if(is.null(subst))	subst <- 1:length(levels(as.factor(esDat$whichComp)))#
   	n.var2 <- max(esDat$ksRank*(!is.na(esDat$ksPVal)), na.rm=TRUE)#
   	pt1 <- xyplot(ksPVal~ksRank|whichComp, groups=weighted, scales = list(alternating = 1), data = esDat,ylim = c(-.1, 1.1), ..., xlab = "Rank of p-value rank for pretreatment variables \n (hollow is weighted, solid is unweighted)", ylab = "KS test p-values", pch = c(19,1), col="black",par.settings = list(strip.background = list(col=stripBgCol)),#
   	subst = (as.factor(esDat$whichComp) %in% levels(as.factor(esDat$whichComp))[subst]) & (esDat$ksRank <= n.var2),#
   	panel = function(...){#
   		panel.xyplot(x=c(1,n.var2), y=c(0,1), col=ltBl, type="l")#
   		panel.xyplot(...)#
   	})#
   	}#
return(pt1)#
	}#
#
}#
#
}
plotUpdate.mnps(mnps.AOD4, plots = 3)
makePlotDat <- twang:::makePlotDat
plotUpdate.mnps(mnps.AOD4, plots = 3)
pairwiseComparison <- twang:::pairwiseComparison
plotUpdate.mnps(mnps.AOD4, plots = 3)
debug(plotUpdate.mnps)
plotUpdate.mnps(mnps.AOD4, plots = 3)
pwc
collapsedP
x$stop.methods
x$stop.method
str(x)
x$stopMethods
Q
undebug(plotUpdate.mnps)
##require(twang); data(AOD); AOD$crimjust[198:202] <- NA; mnps.AOD <- mnps(treat ~ illact + crimjust + subprob + subdep + white, data = AOD, estimand = "ATT", stop.method = c("ks.max","es.max"), n.trees = 1000, treatATT = 'community')#
plotUpdate.mnps <- function(x,plots="optimize", pairwiseMax = TRUE, figureRows = 1, color = TRUE, subset = NULL, ...)#
{#
   # Creates diag.plot plots and sends to current device#
   # x:     ps object #
   # label: Label added to the plot titles#
#
   # extract the propensity scores and weights from the ps object#
   	if(is.null(subset)) subset <- 1:length(x$stopMethods)#
   	ltBl <- ifelse(color, "lightblue","gray80")#
	rdCol <- ifelse(color, "red","black")#
	stripBgCol <- ifelse(color, "#ffe5cc", "transparent")#
	ptSymCol <- ifelse(color, "#0080ff", "black")#
   ifelse(x$estimand == "ATE", noKS <- TRUE, noKS <- FALSE)#
   subst <- whichVar <- pVal <- weighted <- NULL #
   if(length(plots) > 1) stop("The `plots' argument must be of length 1.")#
   if(!(plots %in% c(1,2,3,4,5)) & !(plots %in% c("boxplot","ks","optimize","es","t")))#
   stop("Invalid choice of `plots' argument.")#
   if(plots == 2 | plots == "boxplot"){#
   	boxplot(x, color = color, stop.method = subset, ...)#
   }#
   else{#
   if(!pairwiseMax | plots == "optimize" | plots == 1){#
   nPlot <- x$nFits#
   ptHld <- vector(mode = "list", length = nPlot)#
   for(i in 1:nPlot){#
   	if(x$estimand == "ATT") ptNm <- paste("Balance for", x$levExceptTreatATT[i], "versus unweighted", x$treatATT)#
   	else ptNm <- paste("Balance for", x$treatLev[i], "against others")#
   	ptHld[[i]] <- plot(x$psList[[i]], main = ptNm, plots = plots, noKS = TRUE, color = color, subset=subset, ...)#
   }#
#
#pt1 <- twang:::diag.plot(x, plots, subset = subset, ...)#
figCol <- ceiling(nPlot/figureRows)#
#
if(dev.cur() == 1) dev.new()#
#
curCol <- curRow <- 1#
#
for(i in 1:(nPlot-1)){#
	print(ptHld[[i]], split = c(curCol,curRow,nx = figCol,ny = figureRows), more = TRUE)#
	if(curCol < figCol){#
		curCol <- curCol + 1#
	}#
	else {#
		curCol <- 1#
		curRow <- curRow + 1#
	}#
}#
#
print(ptHld[[nPlot]], split = c(curCol,curRow,nx = figCol,ny = figureRows), more = FALSE)#
#
}#
#
else{  ## if pairwiseMax and plots == something other than optimize#
#
n.tp <- length(x$psList[[1]]$desc)#
n.psFits <- length(x$psList)#
#   	return(esDat)   #
   if (plots == "es" || plots == 3)	{ ## es plot#
   	esDat <- makePlotDat(x$psList[[1]], whichPlot = 3, subsetStopMeth = subset)#
   	nVar <- length(makePlotDat(x$psList[[1]], whichPlot = 3, subsetStopMeth = 1, yOnly = TRUE, incUnw = FALSE)$pVal)#
   	effSzList <- effSzListUnw <- pValListUnw <- pValList <- matrix(NA, nrow = nVar, ncol = length(x$psList))#
   	if(x$estimand == "ATE"){#
   		pwc <- pairwiseComparison(x, collapse.to = "covariate")#
   		}#
   		collapsed <- pwc$max.std.eff.sz[pwc$stop.method %in% x$stopMethods[subset]]#
   		collapsedP <- pwc$min.p[pwc$stop.method %in% x$stopMethods[subset]]#
   		collapsedUnw <- rep(pwc$max.std.eff.sz[pwc$stop.method == "unw"], length(subset))#
   		collapsedUnwP <- rep(pwc$min.p[pwc$stop.method == "unw"], length(subset))#
   	cnt <- 0#
   	for(k in subset){#
   		cnt <- cnt + 1#
   		if(x$estimand == "ATT"){#
   			for(j in 1:length(x$psList)){	#
				x2 <- x$psList[[j]]#
				effSzList[,j] <- makePlotDat(x2, whichPlot = 3, subsetStopMeth = k, yOnly = TRUE, incUnw = FALSE)$effectSize#
				effSzListUnw[,j] <- makePlotDat(x2, whichPlot = 3, subsetStopMeth = 1, yOnly = TRUE, incUnw = TRUE)$effectSize[(nVar + 1):(2*nVar)]#
				pValListUnw[,j] <- makePlotDat(x2, whichPlot = 3, subsetStopMeth = 1, yOnly = TRUE, incUnw = TRUE)$pVal[(nVar + 1):(2*nVar)]#
				pValList[,j] <- makePlotDat(x2, whichPlot = 3, subsetStopMeth = k, yOnly = TRUE, incUnw = FALSE)$pVal	#
			}#
			effSzList <- abs(effSzList)#
			effSzListUnw <- abs(effSzListUnw)#
			collapsed <- apply(effSzList, 1, max)#
			collapsedUnw <- apply(effSzListUnw, 1, max)#
			collapsedP <- apply(pValList < .05, 1, max)#
			collapsedUnwP <- apply(pValListUnw < .05, 1, max)			#
		}#
		#if(x$estimand == "ATE"){#
	   	#	collapsed <- pwc$max.std.eff.sz[pwc$stop.method == x$stop.methods[k]]#
   		#	collapsedP <- pwc$min.p[pwc$stop.method == x$stop.methods[subset]]#
   		#	collapsedUnw <- pwc$max.std.eff.sz[pwc$stop.method == "unw"] < .05#
   		#	collapsedUnwP <- pwc$min.p[pwc$stop.method == "unw"] < .05#
		#}#
		esBigHold <- collapsed > collapsedUnw#
		esDat$effectSize[(1:(2*nVar)) + (cnt-1)*2*nVar] <- c(collapsed, collapsedUnw)#
		esDat$pVal[(1:(2*nVar)) + (cnt-1)*2*nVar] <- c(collapsedP, collapsedUnwP)#
		esDat$esBig[(1:(2*nVar)) + (cnt-1)*2*nVar] <- rep(esBigHold, 2)#
	}#
   	yMax <- min(3,max(esDat[,1])) + .05	#
   	if(max(esDat[,1], na.rm=TRUE) > 3)#
   	warning("Some effect sizes are larger than 3 and may not have been plotted.\n")	#
    nullPlot <- TRUE#
   	subsetHold <- !esDat$esBig #
   	if(any(subsetHold)){#
   		esDatTmp <- esDat#
   		esDatTmp$effectSize[!subsetHold] <- NA#
   		pt1.1 <- xyplot(effectSize ~ weighted | whichComp, groups = whichVar, data = esDatTmp, scales = list(alternating = 1),#
   			ylim = c(-.05, yMax), type = "l", col = ltBl, as.table = TRUE,#
   			ylab = "Absolute standard difference", xlab = NULL, par.settings = list(strip.background = list(col=stripBgCol)),#
   			panel = function(...){#
   				panel.abline(h=c(.2,.5,.8), col="gray80")#
   				panel.xyplot(...)#
		   	})#
   		nullPlot <- FALSE#
   		currPt <- pt1.1#
   	}#
   	subsetHold <- esDat$esBig #
   	if(any(subsetHold)){#
   		esDatTmp <- esDat#
   		esDatTmp$effectSize[!subsetHold] <- NA#
   		pt1.2 <- xyplot(effectSize ~ weighted | whichComp, groups = whichVar, #
   			data = esDatTmp, ylab = "Absolute standard difference", xlab = NULL, as.table = TRUE,#
   			ylim = c(-.05, yMax), type = "l", col = rdCol, par.settings = list(strip.background = list(col=stripBgCol)),#
   			lwd = 2, ...)#
   		if(!nullPlot){#
   			currPt <- currPt + pt1.2#
   		}#
   		else{#
   			currPt <- pt1.2#
   			nullPlot <- FALSE#
   		}#
   	}#
   	if(all(esDat$pVal >= .05)) pchHold <- 19#
   	else if(all(esDat$pVal < .05)) pchHold <- 1#
   	else pchHold <- c(19,1)#
   	pt2 <- xyplot(effectSize ~ weighted | whichComp, groups = (pVal < 0.05), data = esDat,#
   	ylab = "Absolute standard difference", xlab = NULL, as.table = TRUE, #
   	ylim = c(-.05, yMax), type = "p", col = rdCol, pch = pchHold,par.settings = list(strip.background = list(col=stripBgCol)),#
   	...)#
   	if(!nullPlot) currPt <- currPt + pt2#
   	else currPt <- pt2#
   	return(currPt)#
   	}#
   if (plots == "t" || plots == 4) { ## t p-values plot#
#
   	esDat <- makePlotDat(x$psList[[1]], whichPlot = 4, subsetStopMeth = subset)#
   	nVar <- length(makePlotDat(x$psList[[1]], whichPlot = 4, subsetStopMeth = 1, yOnly = TRUE, incUnw = FALSE))#
   	effSzList <- effSzListUnw <- matrix(NA, nrow = nVar, ncol = length(x$psList))   	#
   	if(x$estimand =="ATE") pwc <- pairwiseComparison(x, collapse.to = "covariate")#
   	cnt <- 0#
   	for(k in subset){#
   		cnt <- cnt + 1#
   	for(j in 1:length(x$psList)){	#
	x2 <- x$psList[[j]]#
	effSzList[,j] <- makePlotDat(x2, whichPlot = 4, subsetStopMeth = k, yOnly = TRUE, incUnw = FALSE)#
	effSzListUnw[,j] <- makePlotDat(x2, whichPlot = 4, subsetStopMeth = 1, yOnly = TRUE, incUnw = TRUE)[1:nVar]#
	collapsed <- apply(-1 *effSzList, 1, max)#
	collapsed <- -1 * collapsed#
	if(x$estimand == "ATE") collapsed <- pwc$min.p[pwc$stop.method == x$stopMethods[k]]	#
	collapsedUnw <- apply(-1 * effSzListUnw, 1, max)#
	collapsedUnw <- -1 * collapsedUnw#
	if(x$estimand == "ATE") collapsedUnw <- pwc$min.p[pwc$stop.method == 'unw']		#
	collRanks <- rank(collapsed, ties.method = "first")#
	esBigHold <- collapsed > collapsedUnw#
	esDat$tPVal[(1:(2*nVar)) + (cnt - 1)*2*nVar] <- c(collapsed, collapsedUnw)#
	esDat$tRank[(1:(2*nVar)) + (cnt - 1)*2*nVar] <- rep(collRanks, 2)#
	}#
	}#
   	   #	if(is.null(subst))	subst <- 1:length(levels(as.factor(esDat$whichComp)))#
   	n.var2 <- max(esDat$tRank * (!is.na(esDat$tPVal)), na.rm=TRUE)#
   	pt1 <- xyplot(tPVal~tRank|whichComp, groups = weighted, data=esDat, xlab = "Rank of p-value rank for pretreatment variables \n (hollow is weighted, solid is unweighted)", ylab = "T test p-values", pch = c(19,1), col = "black", scales = list(alternating = 1), par.settings = list(strip.background = list(col=stripBgCol)),#
   	#subst = (as.factor(esDat$whichComp) %in% levels(as.factor(esDat$whichComp))[subst]) & (esDat$tRank <= n.var2), #
   	ylim = c(-.1, 1.1), ..., #
   	   	panel = function(...){#
   	   		panel.xyplot(x=c(1,n.var2), y=c(0,1), col=ltBl, type="l")#
#   		panel.abline(a=0, b=1, col="lightblue")#
   		panel.xyplot(...)#
   		}#
)#
   	}#
   if (plots =="ks" || plots ==5) {  ## ks plot#
   	if(x$estimand =="ATE") pwc <- pairwiseComparison(x, collapse.to = "covariate")#
#
   	esDat <- makePlotDat(x$psList[[1]], whichPlot = 5, subsetStopMeth = subset)#
   	nVar <- length(makePlotDat(x$psList[[1]], whichPlot = 5, subsetStopMeth = 1, yOnly = TRUE, incUnw = FALSE))#
   	effSzList <- effSzListUnw <- matrix(NA, nrow = nVar, ncol = length(x$psList))   	#
   	cnt <- 0#
   	for(k in subset){#
   		cnt <- cnt + 1#
   	for(j in 1:length(x$psList)){	#
	x2 <- x$psList[[j]]#
	effSzList[,j] <- makePlotDat(x2, whichPlot = 5, subsetStopMeth = k, yOnly = TRUE, incUnw = FALSE)#
	effSzListUnw[,j] <- makePlotDat(x2, whichPlot = 5, subsetStopMeth = 1, yOnly = TRUE, incUnw = TRUE)[1:nVar]#
	collapsed <- apply(effSzList, 1, max)#
	if(x$estimand == "ATE") collapsed <- pwc$min.ks.pval[pwc$stop.method == x$stopMethods[k]]#
	collapsedUnw <- apply(effSzListUnw, 1, max)#
	if(x$estimand == "ATE") collapsedUnw <- pwc$min.ks.pval[pwc$stop.method == "unw"]	#
	collRanks <- rank(collapsed, ties.method = "first")#
	esBigHold <- collapsed > collapsedUnw#
	esDat$ksPVal[(1:(2*nVar)) + (cnt-1)*2*nVar] <- c(collapsed, collapsedUnw)#
	esDat$ksRank[(1:(2*nVar)) + (cnt-1)*2*nVar] <- rep(collRanks, 2)#
	}#
	}#
   	if(is.null(subst))	subst <- 1:length(levels(as.factor(esDat$whichComp)))#
   	n.var2 <- max(esDat$ksRank*(!is.na(esDat$ksPVal)), na.rm=TRUE)#
   	pt1 <- xyplot(ksPVal~ksRank|whichComp, groups=weighted, scales = list(alternating = 1), data = esDat,ylim = c(-.1, 1.1), ..., xlab = "Rank of p-value rank for pretreatment variables \n (hollow is weighted, solid is unweighted)", ylab = "KS test p-values", pch = c(19,1), col="black",par.settings = list(strip.background = list(col=stripBgCol)),#
   	subst = (as.factor(esDat$whichComp) %in% levels(as.factor(esDat$whichComp))[subst]) & (esDat$ksRank <= n.var2),#
   	panel = function(...){#
   		panel.xyplot(x=c(1,n.var2), y=c(0,1), col=ltBl, type="l")#
   		panel.xyplot(...)#
   	})#
   	}#
return(pt1)#
	}#
#
}#
#
}
plotUpdate.mnps(mnps.AOD4, plots = 3)
##require(twang); data(AOD); AOD$crimjust[198:202] <- NA; mnps.AOD <- mnps(treat ~ illact + crimjust + subprob + subdep + white, data = AOD, estimand = "ATT", stop.method = c("ks.max","es.max"), n.trees = 1000, treatATT = 'community')#
plotUpdate.mnps <- function(x,plots="optimize", pairwiseMax = TRUE, figureRows = 1, color = TRUE, subset = NULL, ...)#
{#
   # Creates diag.plot plots and sends to current device#
   # x:     ps object #
   # label: Label added to the plot titles#
#
   # extract the propensity scores and weights from the ps object#
   	if(is.null(subset)) subset <- 1:length(x$stopMethods)#
   	ltBl <- ifelse(color, "lightblue","gray80")#
	rdCol <- ifelse(color, "red","black")#
	stripBgCol <- ifelse(color, "#ffe5cc", "transparent")#
	ptSymCol <- ifelse(color, "#0080ff", "black")#
   ifelse(x$estimand == "ATE", noKS <- TRUE, noKS <- FALSE)#
   subst <- whichVar <- pVal <- weighted <- NULL #
   if(length(plots) > 1) stop("The `plots' argument must be of length 1.")#
   if(!(plots %in% c(1,2,3,4,5)) & !(plots %in% c("boxplot","ks","optimize","es","t")))#
   stop("Invalid choice of `plots' argument.")#
   if(plots == 2 | plots == "boxplot"){#
   	boxplot(x, color = color, stop.method = subset, ...)#
   }#
   else{#
   if(!pairwiseMax | plots == "optimize" | plots == 1){#
   nPlot <- x$nFits#
   ptHld <- vector(mode = "list", length = nPlot)#
   for(i in 1:nPlot){#
   	if(x$estimand == "ATT") ptNm <- paste("Balance for", x$levExceptTreatATT[i], "versus unweighted", x$treatATT)#
   	else ptNm <- paste("Balance for", x$treatLev[i], "against others")#
   	ptHld[[i]] <- plot(x$psList[[i]], main = ptNm, plots = plots, noKS = TRUE, color = color, subset=subset, ...)#
   }#
#
#pt1 <- twang:::diag.plot(x, plots, subset = subset, ...)#
figCol <- ceiling(nPlot/figureRows)#
#
if(dev.cur() == 1) dev.new()#
#
curCol <- curRow <- 1#
#
for(i in 1:(nPlot-1)){#
	print(ptHld[[i]], split = c(curCol,curRow,nx = figCol,ny = figureRows), more = TRUE)#
	if(curCol < figCol){#
		curCol <- curCol + 1#
	}#
	else {#
		curCol <- 1#
		curRow <- curRow + 1#
	}#
}#
#
print(ptHld[[nPlot]], split = c(curCol,curRow,nx = figCol,ny = figureRows), more = FALSE)#
#
}#
#
else{  ## if pairwiseMax and plots == something other than optimize#
#
n.tp <- length(x$psList[[1]]$desc)#
n.psFits <- length(x$psList)#
#   	return(esDat)   #
   if (plots == "es" || plots == 3)	{ ## es plot#
   	esDat <- makePlotDat(x$psList[[1]], whichPlot = 3, subsetStopMeth = subset)#
   	nVar <- length(makePlotDat(x$psList[[1]], whichPlot = 3, subsetStopMeth = 1, yOnly = TRUE, incUnw = FALSE)$pVal)#
   	effSzList <- effSzListUnw <- pValListUnw <- pValList <- matrix(NA, nrow = nVar, ncol = length(x$psList))#
   	if(x$estimand == "ATE"){#
   		pwc <- pairwiseComparison(x, collapse.to = "covariate")#
   		}#
   		collapsed <- pwc$max.std.eff.sz[pwc$stop.method %in% x$stopMethods[subset]]#
   		collapsedP <- pwc$min.p[pwc$stop.method %in% x$stopMethods[subset]] < .05#
   		collapsedUnw <- rep(pwc$max.std.eff.sz[pwc$stop.method == "unw"], length(subset))#
   		collapsedUnwP <- rep(pwc$min.p[pwc$stop.method == "unw"], length(subset)) < .05#
   	cnt <- 0#
   	for(k in subset){#
   		cnt <- cnt + 1#
   		if(x$estimand == "ATT"){#
   			for(j in 1:length(x$psList)){	#
				x2 <- x$psList[[j]]#
				effSzList[,j] <- makePlotDat(x2, whichPlot = 3, subsetStopMeth = k, yOnly = TRUE, incUnw = FALSE)$effectSize#
				effSzListUnw[,j] <- makePlotDat(x2, whichPlot = 3, subsetStopMeth = 1, yOnly = TRUE, incUnw = TRUE)$effectSize[(nVar + 1):(2*nVar)]#
				pValListUnw[,j] <- makePlotDat(x2, whichPlot = 3, subsetStopMeth = 1, yOnly = TRUE, incUnw = TRUE)$pVal[(nVar + 1):(2*nVar)]#
				pValList[,j] <- makePlotDat(x2, whichPlot = 3, subsetStopMeth = k, yOnly = TRUE, incUnw = FALSE)$pVal	#
			}#
			effSzList <- abs(effSzList)#
			effSzListUnw <- abs(effSzListUnw)#
			collapsed <- apply(effSzList, 1, max)#
			collapsedUnw <- apply(effSzListUnw, 1, max)#
			collapsedP <- apply(pValList < .05, 1, max)#
			collapsedUnwP <- apply(pValListUnw < .05, 1, max)			#
		}#
		#if(x$estimand == "ATE"){#
	   	#	collapsed <- pwc$max.std.eff.sz[pwc$stop.method == x$stop.methods[k]]#
   		#	collapsedP <- pwc$min.p[pwc$stop.method == x$stop.methods[subset]]#
   		#	collapsedUnw <- pwc$max.std.eff.sz[pwc$stop.method == "unw"] < .05#
   		#	collapsedUnwP <- pwc$min.p[pwc$stop.method == "unw"] < .05#
		#}#
		esBigHold <- collapsed > collapsedUnw#
		esDat$effectSize[(1:(2*nVar)) + (cnt-1)*2*nVar] <- c(collapsed, collapsedUnw)#
		esDat$pVal[(1:(2*nVar)) + (cnt-1)*2*nVar] <- c(collapsedP, collapsedUnwP)#
		esDat$esBig[(1:(2*nVar)) + (cnt-1)*2*nVar] <- rep(esBigHold, 2)#
	}#
   	yMax <- min(3,max(esDat[,1])) + .05	#
   	if(max(esDat[,1], na.rm=TRUE) > 3)#
   	warning("Some effect sizes are larger than 3 and may not have been plotted.\n")	#
    nullPlot <- TRUE#
   	subsetHold <- !esDat$esBig #
   	if(any(subsetHold)){#
   		esDatTmp <- esDat#
   		esDatTmp$effectSize[!subsetHold] <- NA#
   		pt1.1 <- xyplot(effectSize ~ weighted | whichComp, groups = whichVar, data = esDatTmp, scales = list(alternating = 1),#
   			ylim = c(-.05, yMax), type = "l", col = ltBl, as.table = TRUE,#
   			ylab = "Absolute standard difference", xlab = NULL, par.settings = list(strip.background = list(col=stripBgCol)),#
   			panel = function(...){#
   				panel.abline(h=c(.2,.5,.8), col="gray80")#
   				panel.xyplot(...)#
		   	})#
   		nullPlot <- FALSE#
   		currPt <- pt1.1#
   	}#
   	subsetHold <- esDat$esBig #
   	if(any(subsetHold)){#
   		esDatTmp <- esDat#
   		esDatTmp$effectSize[!subsetHold] <- NA#
   		pt1.2 <- xyplot(effectSize ~ weighted | whichComp, groups = whichVar, #
   			data = esDatTmp, ylab = "Absolute standard difference", xlab = NULL, as.table = TRUE,#
   			ylim = c(-.05, yMax), type = "l", col = rdCol, par.settings = list(strip.background = list(col=stripBgCol)),#
   			lwd = 2, ...)#
   		if(!nullPlot){#
   			currPt <- currPt + pt1.2#
   		}#
   		else{#
   			currPt <- pt1.2#
   			nullPlot <- FALSE#
   		}#
   	}#
   	if(all(esDat$pVal >= .05)) pchHold <- 19#
   	else if(all(esDat$pVal < .05)) pchHold <- 1#
   	else pchHold <- c(19,1)#
   	pt2 <- xyplot(effectSize ~ weighted | whichComp, groups = (pVal < 0.05), data = esDat,#
   	ylab = "Absolute standard difference", xlab = NULL, as.table = TRUE, #
   	ylim = c(-.05, yMax), type = "p", col = rdCol, pch = pchHold,par.settings = list(strip.background = list(col=stripBgCol)),#
   	...)#
   	if(!nullPlot) currPt <- currPt + pt2#
   	else currPt <- pt2#
   	return(currPt)#
   	}#
   if (plots == "t" || plots == 4) { ## t p-values plot#
#
   	esDat <- makePlotDat(x$psList[[1]], whichPlot = 4, subsetStopMeth = subset)#
   	nVar <- length(makePlotDat(x$psList[[1]], whichPlot = 4, subsetStopMeth = 1, yOnly = TRUE, incUnw = FALSE))#
   	effSzList <- effSzListUnw <- matrix(NA, nrow = nVar, ncol = length(x$psList))   	#
   	if(x$estimand =="ATE") pwc <- pairwiseComparison(x, collapse.to = "covariate")#
   	cnt <- 0#
   	for(k in subset){#
   		cnt <- cnt + 1#
   	for(j in 1:length(x$psList)){	#
	x2 <- x$psList[[j]]#
	effSzList[,j] <- makePlotDat(x2, whichPlot = 4, subsetStopMeth = k, yOnly = TRUE, incUnw = FALSE)#
	effSzListUnw[,j] <- makePlotDat(x2, whichPlot = 4, subsetStopMeth = 1, yOnly = TRUE, incUnw = TRUE)[1:nVar]#
	collapsed <- apply(-1 *effSzList, 1, max)#
	collapsed <- -1 * collapsed#
	if(x$estimand == "ATE") collapsed <- pwc$min.p[pwc$stop.method == x$stopMethods[k]]	#
	collapsedUnw <- apply(-1 * effSzListUnw, 1, max)#
	collapsedUnw <- -1 * collapsedUnw#
	if(x$estimand == "ATE") collapsedUnw <- pwc$min.p[pwc$stop.method == 'unw']		#
	collRanks <- rank(collapsed, ties.method = "first")#
	esBigHold <- collapsed > collapsedUnw#
	esDat$tPVal[(1:(2*nVar)) + (cnt - 1)*2*nVar] <- c(collapsed, collapsedUnw)#
	esDat$tRank[(1:(2*nVar)) + (cnt - 1)*2*nVar] <- rep(collRanks, 2)#
	}#
	}#
   	   #	if(is.null(subst))	subst <- 1:length(levels(as.factor(esDat$whichComp)))#
   	n.var2 <- max(esDat$tRank * (!is.na(esDat$tPVal)), na.rm=TRUE)#
   	pt1 <- xyplot(tPVal~tRank|whichComp, groups = weighted, data=esDat, xlab = "Rank of p-value rank for pretreatment variables \n (hollow is weighted, solid is unweighted)", ylab = "T test p-values", pch = c(19,1), col = "black", scales = list(alternating = 1), par.settings = list(strip.background = list(col=stripBgCol)),#
   	#subst = (as.factor(esDat$whichComp) %in% levels(as.factor(esDat$whichComp))[subst]) & (esDat$tRank <= n.var2), #
   	ylim = c(-.1, 1.1), ..., #
   	   	panel = function(...){#
   	   		panel.xyplot(x=c(1,n.var2), y=c(0,1), col=ltBl, type="l")#
#   		panel.abline(a=0, b=1, col="lightblue")#
   		panel.xyplot(...)#
   		}#
)#
   	}#
   if (plots =="ks" || plots ==5) {  ## ks plot#
   	if(x$estimand =="ATE") pwc <- pairwiseComparison(x, collapse.to = "covariate")#
#
   	esDat <- makePlotDat(x$psList[[1]], whichPlot = 5, subsetStopMeth = subset)#
   	nVar <- length(makePlotDat(x$psList[[1]], whichPlot = 5, subsetStopMeth = 1, yOnly = TRUE, incUnw = FALSE))#
   	effSzList <- effSzListUnw <- matrix(NA, nrow = nVar, ncol = length(x$psList))   	#
   	cnt <- 0#
   	for(k in subset){#
   		cnt <- cnt + 1#
   	for(j in 1:length(x$psList)){	#
	x2 <- x$psList[[j]]#
	effSzList[,j] <- makePlotDat(x2, whichPlot = 5, subsetStopMeth = k, yOnly = TRUE, incUnw = FALSE)#
	effSzListUnw[,j] <- makePlotDat(x2, whichPlot = 5, subsetStopMeth = 1, yOnly = TRUE, incUnw = TRUE)[1:nVar]#
	collapsed <- apply(effSzList, 1, max)#
	if(x$estimand == "ATE") collapsed <- pwc$min.ks.pval[pwc$stop.method == x$stopMethods[k]]#
	collapsedUnw <- apply(effSzListUnw, 1, max)#
	if(x$estimand == "ATE") collapsedUnw <- pwc$min.ks.pval[pwc$stop.method == "unw"]	#
	collRanks <- rank(collapsed, ties.method = "first")#
	esBigHold <- collapsed > collapsedUnw#
	esDat$ksPVal[(1:(2*nVar)) + (cnt-1)*2*nVar] <- c(collapsed, collapsedUnw)#
	esDat$ksRank[(1:(2*nVar)) + (cnt-1)*2*nVar] <- rep(collRanks, 2)#
	}#
	}#
   	if(is.null(subst))	subst <- 1:length(levels(as.factor(esDat$whichComp)))#
   	n.var2 <- max(esDat$ksRank*(!is.na(esDat$ksPVal)), na.rm=TRUE)#
   	pt1 <- xyplot(ksPVal~ksRank|whichComp, groups=weighted, scales = list(alternating = 1), data = esDat,ylim = c(-.1, 1.1), ..., xlab = "Rank of p-value rank for pretreatment variables \n (hollow is weighted, solid is unweighted)", ylab = "KS test p-values", pch = c(19,1), col="black",par.settings = list(strip.background = list(col=stripBgCol)),#
   	subst = (as.factor(esDat$whichComp) %in% levels(as.factor(esDat$whichComp))[subst]) & (esDat$ksRank <= n.var2),#
   	panel = function(...){#
   		panel.xyplot(x=c(1,n.var2), y=c(0,1), col=ltBl, type="l")#
   		panel.xyplot(...)#
   	})#
   	}#
return(pt1)#
	}#
#
}#
#
}
plotUpdate.mnps(mnps.AOD4, plots = 3)
rm(list=ls())
require(rstan)#
#
load("/Users/burgette/Desktop/kirstenRanking/ratings for Lane05092014.RData")#
#
e4Dt <- subset(dt, orig_grade == "(E4) SRA")#
#
cd <- "data{#
	int<lower =2> K;#
	int<lower=1> N;#
	int<lower = 1> nSqd;#
	int<lower=1,upper=K> y[N];#
	vector[N] tstSc;#
	int sqd[N];#
	}#
parameters{#
	real bt;#
	real sqdRanef[nSqd];#
	ordered[K-1] c;#
	}#
model {#
	vector[K] theta;#
	for(n in 1:N){#
		real eta;#
		sqdRanef ~ normal(0, 1);#
		eta <- tstSc[n] * bt + sqdRanef[sqd[n]];#
		theta[1] <- 1-Phi(eta - c[1]);#
		for(k in 2:(K-1)){#
			theta[k] <- Phi(eta - c[k-1]) - Phi(eta - c[k]);#
		}#
		theta[K] <- Phi(eta - c[K-1]);#
		y[n] ~ categorical(theta);#
	}#
}#
"#
#
e4Dt <- subset(dt, orig_grade == "(E4) SRA")#
e4Dt$rank <- as.numeric(as.character(e4Dt$rank))#
e4Dt <- subset(e4Dt, !is.na(rank))#
e4Dt <- subset(e4Dt, !(pas %in% c("MN1LFCR8","AU4WFCM8","MT1CFK3C","NJ1CFCJF")))#
e4Dt$sqd <- as.numeric(as.factor(e4Dt$pas))#
e4Dt <- subset(e4Dt, !is.na(phs_pt))#
#
stanDt <- list(K = 5, N = nrow(e4Dt), nSqd = length(table(e4Dt$sqd)), y = e4Dt$rank, tstSc = with(e4Dt, (eprsc-mean(phs_pt))/sd(phs_pt)), sqd = e4Dt$sqd)#
#
ft <- stan(model_code = cd, data = stanDt, iter = 500, chains = 2)
stanDt <- list(K = 5, N = nrow(e4Dt), nSqd = length(table(e4Dt$sqd)), y = e4Dt$rank, tstSc = with(e4Dt, (phs_pt-mean(phs_pt))/sd(phs_pt)), sqd = e4Dt$sqd)
ft <- stan(model_code = cd, data = stanDt, iter = 500, chains = 2)
print(ft, digits = 3)
e4Dt <- subset(dt, orig_grade == "(E5) SSG")#
e4Dt$rank <- as.numeric(as.character(e4Dt$rank))#
e4Dt <- subset(e4Dt, !is.na(rank))#
e4Dt <- subset(e4Dt, !(pas %in% c("MN1LFCR8","AU4WFCM8","MT1CFK3C","NJ1CFCJF")))#
e4Dt$sqd <- as.numeric(as.factor(e4Dt$pas))#
e4Dt <- subset(e4Dt, !is.na(phs_pt))#
#
stanDt <- list(K = 5, N = nrow(e4Dt), nSqd = length(table(e4Dt$sqd)), y = e4Dt$rank, tstSc = with(e4Dt, (phs_pt-mean(phs_pt))/sd(phs_pt)), sqd = e4Dt$sqd)#
#
ft <- stan(model_code = cd, data = stanDt, iter = 500, chains = 2)#
#
print(ft, digits = 3)
e4Dt <- subset(dt, orig_grade == "(E6) TSG")#
e4Dt$rank <- as.numeric(as.character(e4Dt$rank))#
e4Dt <- subset(e4Dt, !is.na(rank))#
e4Dt <- subset(e4Dt, !(pas %in% c("MN1LFCR8","AU4WFCM8","MT1CFK3C","NJ1CFCJF")))#
e4Dt$sqd <- as.numeric(as.factor(e4Dt$pas))#
e4Dt <- subset(e4Dt, !is.na(phs_pt))#
#
stanDt <- list(K = 5, N = nrow(e4Dt), nSqd = length(table(e4Dt$sqd)), y = e4Dt$rank, tstSc = with(e4Dt, (phs_pt-mean(phs_pt))/sd(phs_pt)), sqd = e4Dt$sqd)#
#
ft <- stan(model_code = cd, data = stanDt, iter = 500, chains = 2)#
#
print(ft, digits = 3)
q()
library(twang)#
data(AOD)#
set.seed(1)#
####################################################
### code chunk number 3: mnps.rnw:130-136#
####################################################
mnps.AOD <- mnps(treat ~ illact + crimjust + subprob + subdep + white,#
                 data = AOD, #
                 estimand = "ATE", #
                 verbose = FALSE, #
                 stop.method = c("es.mean", "ks.mean"), #
                 n.trees = 3000)
plot(mnps.AOD, plots = 1)
plot(mnps.AOD, plots = 2)
plot(mnps.AOD, plots = 3)
##require(twang); data(AOD); AOD$crimjust[198:202] <- NA; mnps.AOD <- mnps(treat ~ illact + crimjust + subprob + subdep + white, data = AOD, estimand = "ATT", stop.method = c("ks.max","es.max"), n.trees = 1000, treatATT = 'community')#
plot.mnps <- function(x,plots="optimize", pairwiseMax = TRUE, figureRows = 1, color = TRUE, subset = NULL, ...)#
{#
   # Creates diag.plot plots and sends to current device#
   # x:     ps object #
   # label: Label added to the plot titles#
#
   # extract the propensity scores and weights from the ps object#
   	if(is.null(subset)) subset <- 1:length(x$stopMethods)#
   	ltBl <- ifelse(color, "lightblue","gray80")#
	rdCol <- ifelse(color, "red","black")#
	stripBgCol <- ifelse(color, "#ffe5cc", "transparent")#
	ptSymCol <- ifelse(color, "#0080ff", "black")#
   ifelse(x$estimand == "ATE", noKS <- TRUE, noKS <- FALSE)#
   subst <- whichVar <- pVal <- weighted <- NULL #
   if(length(plots) > 1) stop("The `plots' argument must be of length 1.")#
   if(!(plots %in% c(1,2,3,4,5)) & !(plots %in% c("boxplot","ks","optimize","es","t")))#
   stop("Invalid choice of `plots' argument.")#
   if(plots == 2 | plots == "boxplot"){#
   	boxplot(x, color = color, stop.method = subset, ...)#
   }#
   else{#
   if(!pairwiseMax | plots == "optimize" | plots == 1){#
   nPlot <- x$nFits#
   ptHld <- vector(mode = "list", length = nPlot)#
   for(i in 1:nPlot){#
   	if(x$estimand == "ATT") ptNm <- paste("Balance for", x$levExceptTreatATT[i], "versus unweighted", x$treatATT)#
   	else ptNm <- paste("Balance for", x$treatLev[i], "against others")#
   	ptHld[[i]] <- plot(x$psList[[i]], main = ptNm, plots = plots, noKS = TRUE, color = color, subset=subset, ...)#
   }#
#
#pt1 <- twang:::diag.plot(x, plots, subset = subset, ...)#
figCol <- ceiling(nPlot/figureRows)#
#
if(dev.cur() == 1) dev.new()#
#
curCol <- curRow <- 1#
#
for(i in 1:(nPlot-1)){#
	print(ptHld[[i]], split = c(curCol,curRow,nx = figCol,ny = figureRows), more = TRUE)#
	if(curCol < figCol){#
		curCol <- curCol + 1#
	}#
	else {#
		curCol <- 1#
		curRow <- curRow + 1#
	}#
}#
#
print(ptHld[[nPlot]], split = c(curCol,curRow,nx = figCol,ny = figureRows), more = FALSE)#
#
}#
#
else{  ## if pairwiseMax and plots == something other than optimize#
#
n.tp <- length(x$psList[[1]]$desc)#
n.psFits <- length(x$psList)#
#   	return(esDat)   #
   if (plots == "es" || plots == 3)	{ ## es plot#
   	esDat <- makePlotDat(x$psList[[1]], whichPlot = 3, subsetStopMeth = subset)#
   	nVar <- length(makePlotDat(x$psList[[1]], whichPlot = 3, subsetStopMeth = 1, yOnly = TRUE, incUnw = FALSE)$pVal)#
   	effSzList <- effSzListUnw <- pValListUnw <- pValList <- matrix(NA, nrow = nVar, ncol = length(x$psList))#
   	pwc <- bal.table(x, collapse.to = "covariate")#
   	#if(x$estimand == "ATE"){#
   	#	pwc <- pairwiseComparison(x, collapse.to = "covariate")	#
   	#	}#
   	cnt <- 0#
   	for(k in subset){#
   		cnt <- cnt + 1#
   		#if(x$estimand == "ATT"){#
   		#for(j in 1:length(x$psList)){	#
			#x2 <- x$psList[[j]]#
			#effSzList[,j] <- makePlotDat(x2, whichPlot = 3, subsetStopMeth = k, yOnly = TRUE, incUnw = FALSE)$effectSize#
			#effSzListUnw[,j] <- makePlotDat(x2, whichPlot = 3, subsetStopMeth = 1, yOnly = TRUE, incUnw = TRUE)$effectSize[(nVar + 1):(2*nVar)]#
			#pValListUnw[,j] <- makePlotDat(x2, whichPlot = 3, subsetStopMeth = 1, yOnly = TRUE, incUnw = TRUE)$pVal[(nVar + 1):(2*nVar)]#
			#pValList[,j] <- makePlotDat(x2, whichPlot = 3, subsetStopMeth = k, yOnly = TRUE, incUnw = FALSE)$pVal	#
			#}#
			#effSzList <- abs(effSzList)#
			#effSzListUnw <- abs(effSzListUnw)#
			#collapsed <- apply(effSzList, 1, max)#
			#collapsedUnw <- apply(effSzListUnw, 1, max)#
			#collapsedP <- apply(pValList < .05, 1, max)#
			#collapsedUnwP <- apply(pValListUnw < .05, 1, max)	#
			collapsed <- pwc$max.std.eff.sz[pwc$stop.method == x$stopMethods[k]]#
   			collapsedP <- pwc$min.p[pwc$stop.method == x$stopMethods[k]] < .05#
   			collapsedUnw <- rep(pwc$max.std.eff.sz[pwc$stop.method == "unw"], length(subset))#
   			collapsedUnwP <- rep(pwc$min.p[pwc$stop.method == "unw"], length(subset)) < .05		#
		#}#
		esBigHold <- collapsed > collapsedUnw#
		esDat$effectSize[(1:(2*nVar)) + (cnt-1)*2*nVar] <- c(collapsed, collapsedUnw)#
		esDat$pVal[(1:(2*nVar)) + (cnt-1)*2*nVar] <- c(collapsedP, collapsedUnwP)#
		esDat$esBig[(1:(2*nVar)) + (cnt-1)*2*nVar] <- rep(esBigHold, 2)#
	}#
   	yMax <- min(3,max(esDat[,1])) + .05	#
   	if(max(esDat[,1], na.rm=TRUE) > 3)#
   	warning("Some effect sizes are larger than 3 and may not have been plotted.\n")	#
    nullPlot <- TRUE#
   	subsetHold <- !esDat$esBig #
   	if(any(subsetHold)){#
   		esDatTmp <- esDat#
   		esDatTmp$effectSize[!subsetHold] <- NA#
   		pt1.1 <- xyplot(effectSize ~ weighted | whichComp, groups = whichVar, data = esDatTmp, scales = list(alternating = 1),#
   			ylim = c(-.05, yMax), type = "l", col = ltBl, as.table = TRUE,#
   			ylab = "Absolute standardized difference \n (maximum pairwise)", xlab = NULL, par.settings = list(strip.background = list(col=stripBgCol)),#
   			panel = function(...){#
   				panel.abline(h=c(.2,.5,.8), col="gray80")#
   				panel.xyplot(...)#
		   	})#
   		nullPlot <- FALSE#
   		currPt <- pt1.1#
   	}#
   	subsetHold <- esDat$esBig #
   	if(any(subsetHold)){#
   		esDatTmp <- esDat#
   		esDatTmp$effectSize[!subsetHold] <- NA#
   		pt1.2 <- xyplot(effectSize ~ weighted | whichComp, groups = whichVar, #
   			data = esDatTmp, ylab = "Absolute standard difference", xlab = NULL, as.table = TRUE,#
   			ylim = c(-.05, yMax), type = "l", col = rdCol, par.settings = list(strip.background = list(col=stripBgCol)),#
   			lwd = 2, ...)#
   		if(!nullPlot){#
   			currPt <- currPt + pt1.2#
   		}#
   		else{#
   			currPt <- pt1.2#
   			nullPlot <- FALSE#
   		}#
   	}#
   	if(all(esDat$pVal >= .05)) pchHold <- 19#
   	else if(all(esDat$pVal < .05)) pchHold <- 1#
   	else pchHold <- c(19,1)#
   	pt2 <- xyplot(effectSize ~ weighted | whichComp, groups = (pVal < 0.05), data = esDat,#
   	ylab = "Absolute standard difference", xlab = NULL, as.table = TRUE, #
   	ylim = c(-.05, yMax), type = "p", col = rdCol, pch = pchHold,par.settings = list(strip.background = list(col=stripBgCol)),#
   	...)#
   	if(!nullPlot) currPt <- currPt + pt2#
   	else currPt <- pt2#
   	return(currPt)#
   	}#
   if (plots == "t" || plots == 4) { ## t p-values plot#
#
   	esDat <- makePlotDat(x$psList[[1]], whichPlot = 4, subsetStopMeth = subset)#
   	nVar <- length(makePlotDat(x$psList[[1]], whichPlot = 4, subsetStopMeth = 1, yOnly = TRUE, incUnw = FALSE))#
   	effSzList <- effSzListUnw <- matrix(NA, nrow = nVar, ncol = length(x$psList))   	#
   	pwc <- bal.table(x, collapse.to = "covariate")#
   	cnt <- 0#
   	for(k in subset){#
   		cnt <- cnt + 1#
   	for(j in 1:length(x$psList)){	#
		collapsed <- pwc$min.p[pwc$stop.method == x$stopMethods[k]]	#
		collapsedUnw <- pwc$min.p[pwc$stop.method == 'unw']		#
		collRanks <- rank(collapsed, ties.method = "first")#
		esBigHold <- collapsed > collapsedUnw#
		esDat$tPVal[(1:(2*nVar)) + (cnt - 1)*2*nVar] <- c(collapsed, collapsedUnw)#
		esDat$tRank[(1:(2*nVar)) + (cnt - 1)*2*nVar] <- rep(collRanks, 2)#
	}#
	}#
   	   #	if(is.null(subst))	subst <- 1:length(levels(as.factor(esDat$whichComp)))#
   	n.var2 <- max(esDat$tRank * (!is.na(esDat$tPVal)), na.rm=TRUE)#
   	pt1 <- xyplot(tPVal~tRank|whichComp, groups = weighted, data=esDat, xlab = "Rank of p-value rank for pretreatment variables \n (hollow is weighted, solid is unweighted)", ylab = "t- and chi-squared p-values \n (pairwise minimum)", pch = c(19,1), col = "black", scales = list(alternating = 1), par.settings = list(strip.background = list(col=stripBgCol)),#
   	#subst = (as.factor(esDat$whichComp) %in% levels(as.factor(esDat$whichComp))[subst]) & (esDat$tRank <= n.var2), #
   	ylim = c(-.1, 1.1), ..., #
   	   	panel = function(...){#
   	   		panel.xyplot(x=c(1,n.var2), y=c(0,1), col=ltBl, type="l")#
#   		panel.abline(a=0, b=1, col="lightblue")#
   		panel.xyplot(...)#
   		}#
)#
   	}#
   if (plots =="ks" || plots ==5) {  ## ks plot#
   	if(x$estimand =="ATE") pwc <- pairwiseComparison(x, collapse.to = "covariate")#
#
   	esDat <- makePlotDat(x$psList[[1]], whichPlot = 5, subsetStopMeth = subset)#
   	nVar <- length(makePlotDat(x$psList[[1]], whichPlot = 5, subsetStopMeth = 1, yOnly = TRUE, incUnw = FALSE))#
   	effSzList <- effSzListUnw <- matrix(NA, nrow = nVar, ncol = length(x$psList))   	#
   	cnt <- 0#
   	for(k in subset){#
   		cnt <- cnt + 1#
   	for(j in 1:length(x$psList)){	#
	x2 <- x$psList[[j]]#
	effSzList[,j] <- makePlotDat(x2, whichPlot = 5, subsetStopMeth = k, yOnly = TRUE, incUnw = FALSE)#
	effSzListUnw[,j] <- makePlotDat(x2, whichPlot = 5, subsetStopMeth = 1, yOnly = TRUE, incUnw = TRUE)[1:nVar]#
	collapsed <- apply(effSzList, 1, max)#
	if(x$estimand == "ATE") collapsed <- pwc$min.ks.pval[pwc$stop.method == x$stopMethods[k]]#
	collapsedUnw <- apply(effSzListUnw, 1, max)#
	if(x$estimand == "ATE") collapsedUnw <- pwc$min.ks.pval[pwc$stop.method == "unw"]	#
	collRanks <- rank(collapsed, ties.method = "first")#
	esBigHold <- collapsed > collapsedUnw#
	esDat$ksPVal[(1:(2*nVar)) + (cnt-1)*2*nVar] <- c(collapsed, collapsedUnw)#
	esDat$ksRank[(1:(2*nVar)) + (cnt-1)*2*nVar] <- rep(collRanks, 2)#
	}#
	}#
   	if(is.null(subst))	subst <- 1:length(levels(as.factor(esDat$whichComp)))#
   	n.var2 <- max(esDat$ksRank*(!is.na(esDat$ksPVal)), na.rm=TRUE)#
   	pt1 <- xyplot(ksPVal~ksRank|whichComp, groups=weighted, scales = list(alternating = 1), data = esDat,ylim = c(-.1, 1.1), ..., xlab = "Rank of p-value rank for pretreatment variables \n (hollow is weighted, solid is unweighted)", ylab = "KS test p-values", pch = c(19,1), col="black",par.settings = list(strip.background = list(col=stripBgCol)),#
   	subst = (as.factor(esDat$whichComp) %in% levels(as.factor(esDat$whichComp))[subst]) & (esDat$ksRank <= n.var2),#
   	panel = function(...){#
   		panel.xyplot(x=c(1,n.var2), y=c(0,1), col=ltBl, type="l")#
   		panel.xyplot(...)#
   	})#
   	}#
return(pt1)#
	}#
#
}#
#
}
plot.mnps(mnps.AOD, plots = 3)
makePlotDat <- twang:::makePlotDat
plot.mnps(mnps.AOD, plots = 3)
plot(mnps.AOD, plots = 3)
debug(twang:::plot.mnps)
plot(mnps.AOD, plots = 3)
debug(plot.mnps)
plot(mnps.AOD, plots = 3)
subset
k
d
nVar
dim(esDat)
head(esDat)
esDat
collapsed
cnt
(1:(2*nVar)) + (cnt-1)*2*nVar
c(collapsed, collapsedUnw)
?meansTable
Q
means.table
?means.table
plot(mnps.AOD, plots = 3)
subset
collapsedUnw
Q
##require(twang); data(AOD); AOD$crimjust[198:202] <- NA; mnps.AOD <- mnps(treat ~ illact + crimjust + subprob + subdep + white, data = AOD, estimand = "ATT", stop.method = c("ks.max","es.max"), n.trees = 1000, treatATT = 'community')#
plot.mnps <- function(x,plots="optimize", pairwiseMax = TRUE, figureRows = 1, color = TRUE, subset = NULL, ...)#
{#
   # Creates diag.plot plots and sends to current device#
   # x:     ps object #
   # label: Label added to the plot titles#
#
   # extract the propensity scores and weights from the ps object#
   	if(is.null(subset)) subset <- 1:length(x$stopMethods)#
   	ltBl <- ifelse(color, "lightblue","gray80")#
	rdCol <- ifelse(color, "red","black")#
	stripBgCol <- ifelse(color, "#ffe5cc", "transparent")#
	ptSymCol <- ifelse(color, "#0080ff", "black")#
   ifelse(x$estimand == "ATE", noKS <- TRUE, noKS <- FALSE)#
   subst <- whichVar <- pVal <- weighted <- NULL #
   if(length(plots) > 1) stop("The `plots' argument must be of length 1.")#
   if(!(plots %in% c(1,2,3,4,5)) & !(plots %in% c("boxplot","ks","optimize","es","t")))#
   stop("Invalid choice of `plots' argument.")#
   if(plots == 2 | plots == "boxplot"){#
   	boxplot(x, color = color, stop.method = subset, ...)#
   }#
   else{#
   if(!pairwiseMax | plots == "optimize" | plots == 1){#
   nPlot <- x$nFits#
   ptHld <- vector(mode = "list", length = nPlot)#
   for(i in 1:nPlot){#
   	if(x$estimand == "ATT") ptNm <- paste("Balance for", x$levExceptTreatATT[i], "versus unweighted", x$treatATT)#
   	else ptNm <- paste("Balance for", x$treatLev[i], "against others")#
   	ptHld[[i]] <- plot(x$psList[[i]], main = ptNm, plots = plots, noKS = TRUE, color = color, subset=subset, ...)#
   }#
#
#pt1 <- twang:::diag.plot(x, plots, subset = subset, ...)#
figCol <- ceiling(nPlot/figureRows)#
#
if(dev.cur() == 1) dev.new()#
#
curCol <- curRow <- 1#
#
for(i in 1:(nPlot-1)){#
	print(ptHld[[i]], split = c(curCol,curRow,nx = figCol,ny = figureRows), more = TRUE)#
	if(curCol < figCol){#
		curCol <- curCol + 1#
	}#
	else {#
		curCol <- 1#
		curRow <- curRow + 1#
	}#
}#
#
print(ptHld[[nPlot]], split = c(curCol,curRow,nx = figCol,ny = figureRows), more = FALSE)#
#
}#
#
else{  ## if pairwiseMax and plots == something other than optimize#
#
n.tp <- length(x$psList[[1]]$desc)#
n.psFits <- length(x$psList)#
#   	return(esDat)   #
   if (plots == "es" || plots == 3)	{ ## es plot#
   	esDat <- makePlotDat(x$psList[[1]], whichPlot = 3, subsetStopMeth = subset)#
   	nVar <- length(makePlotDat(x$psList[[1]], whichPlot = 3, subsetStopMeth = 1, yOnly = TRUE, incUnw = FALSE)$pVal)#
   	effSzList <- effSzListUnw <- pValListUnw <- pValList <- matrix(NA, nrow = nVar, ncol = length(x$psList))#
   	pwc <- bal.table(x, collapse.to = "covariate")#
   	#if(x$estimand == "ATE"){#
   	#	pwc <- pairwiseComparison(x, collapse.to = "covariate")	#
   	#	}#
   	cnt <- 0#
   	for(k in subset){#
   		cnt <- cnt + 1#
   		#if(x$estimand == "ATT"){#
   		#for(j in 1:length(x$psList)){	#
			#x2 <- x$psList[[j]]#
			#effSzList[,j] <- makePlotDat(x2, whichPlot = 3, subsetStopMeth = k, yOnly = TRUE, incUnw = FALSE)$effectSize#
			#effSzListUnw[,j] <- makePlotDat(x2, whichPlot = 3, subsetStopMeth = 1, yOnly = TRUE, incUnw = TRUE)$effectSize[(nVar + 1):(2*nVar)]#
			#pValListUnw[,j] <- makePlotDat(x2, whichPlot = 3, subsetStopMeth = 1, yOnly = TRUE, incUnw = TRUE)$pVal[(nVar + 1):(2*nVar)]#
			#pValList[,j] <- makePlotDat(x2, whichPlot = 3, subsetStopMeth = k, yOnly = TRUE, incUnw = FALSE)$pVal	#
			#}#
			#effSzList <- abs(effSzList)#
			#effSzListUnw <- abs(effSzListUnw)#
			#collapsed <- apply(effSzList, 1, max)#
			#collapsedUnw <- apply(effSzListUnw, 1, max)#
			#collapsedP <- apply(pValList < .05, 1, max)#
			#collapsedUnwP <- apply(pValListUnw < .05, 1, max)	#
			collapsed <- pwc$max.std.eff.sz[pwc$stop.method == x$stopMethods[k]]#
   			collapsedP <- pwc$min.p[pwc$stop.method == x$stopMethods[k]] < .05#
#   			collapsedUnw <- rep(pwc$max.std.eff.sz[pwc$stop.method == "unw"], length(subset))#
#   			collapsedUnwP <- rep(pwc$min.p[pwc$stop.method == "unw"], length(subset)) < .05		#
   			collapsedUnw <- rep(pwc$max.std.eff.sz[pwc$stop.method == "unw"], length(subset))#
   			collapsedUnwP <- rep(pwc$min.p[pwc$stop.method == "unw"], length(subset)) < .05		#
		#}#
		esBigHold <- collapsed > collapsedUnw#
		esDat$effectSize[(1:(2*nVar)) + (cnt-1)*2*nVar] <- c(collapsed, collapsedUnw)#
		esDat$pVal[(1:(2*nVar)) + (cnt-1)*2*nVar] <- c(collapsedP, collapsedUnwP)#
		esDat$esBig[(1:(2*nVar)) + (cnt-1)*2*nVar] <- rep(esBigHold, 2)#
	}#
   	yMax <- min(3,max(esDat[,1])) + .05	#
   	if(max(esDat[,1], na.rm=TRUE) > 3)#
   	warning("Some effect sizes are larger than 3 and may not have been plotted.\n")	#
    nullPlot <- TRUE#
   	subsetHold <- !esDat$esBig #
   	if(any(subsetHold)){#
   		esDatTmp <- esDat#
   		esDatTmp$effectSize[!subsetHold] <- NA#
   		pt1.1 <- xyplot(effectSize ~ weighted | whichComp, groups = whichVar, data = esDatTmp, scales = list(alternating = 1),#
   			ylim = c(-.05, yMax), type = "l", col = ltBl, as.table = TRUE,#
   			ylab = "Absolute standardized difference \n (maximum pairwise)", xlab = NULL, par.settings = list(strip.background = list(col=stripBgCol)),#
   			panel = function(...){#
   				panel.abline(h=c(.2,.5,.8), col="gray80")#
   				panel.xyplot(...)#
		   	})#
   		nullPlot <- FALSE#
   		currPt <- pt1.1#
   	}#
   	subsetHold <- esDat$esBig #
   	if(any(subsetHold)){#
   		esDatTmp <- esDat#
   		esDatTmp$effectSize[!subsetHold] <- NA#
   		pt1.2 <- xyplot(effectSize ~ weighted | whichComp, groups = whichVar, #
   			data = esDatTmp, ylab = "Absolute standard difference", xlab = NULL, as.table = TRUE,#
   			ylim = c(-.05, yMax), type = "l", col = rdCol, par.settings = list(strip.background = list(col=stripBgCol)),#
   			lwd = 2, ...)#
   		if(!nullPlot){#
   			currPt <- currPt + pt1.2#
   		}#
   		else{#
   			currPt <- pt1.2#
   			nullPlot <- FALSE#
   		}#
   	}#
   	if(all(esDat$pVal >= .05)) pchHold <- 19#
   	else if(all(esDat$pVal < .05)) pchHold <- 1#
   	else pchHold <- c(19,1)#
   	pt2 <- xyplot(effectSize ~ weighted | whichComp, groups = (pVal < 0.05), data = esDat,#
   	ylab = "Absolute standard difference", xlab = NULL, as.table = TRUE, #
   	ylim = c(-.05, yMax), type = "p", col = rdCol, pch = pchHold,par.settings = list(strip.background = list(col=stripBgCol)),#
   	...)#
   	if(!nullPlot) currPt <- currPt + pt2#
   	else currPt <- pt2#
   	return(currPt)#
   	}#
   if (plots == "t" || plots == 4) { ## t p-values plot#
#
   	esDat <- makePlotDat(x$psList[[1]], whichPlot = 4, subsetStopMeth = subset)#
   	nVar <- length(makePlotDat(x$psList[[1]], whichPlot = 4, subsetStopMeth = 1, yOnly = TRUE, incUnw = FALSE))#
   	effSzList <- effSzListUnw <- matrix(NA, nrow = nVar, ncol = length(x$psList))   	#
   	pwc <- bal.table(x, collapse.to = "covariate")#
   	cnt <- 0#
   	for(k in subset){#
   		cnt <- cnt + 1#
   	for(j in 1:length(x$psList)){	#
		collapsed <- pwc$min.p[pwc$stop.method == x$stopMethods[k]]	#
		collapsedUnw <- pwc$min.p[pwc$stop.method == 'unw']		#
		collRanks <- rank(collapsed, ties.method = "first")#
		esBigHold <- collapsed > collapsedUnw#
		esDat$tPVal[(1:(2*nVar)) + (cnt - 1)*2*nVar] <- c(collapsed, collapsedUnw)#
		esDat$tRank[(1:(2*nVar)) + (cnt - 1)*2*nVar] <- rep(collRanks, 2)#
	}#
	}#
   	   #	if(is.null(subst))	subst <- 1:length(levels(as.factor(esDat$whichComp)))#
   	n.var2 <- max(esDat$tRank * (!is.na(esDat$tPVal)), na.rm=TRUE)#
   	pt1 <- xyplot(tPVal~tRank|whichComp, groups = weighted, data=esDat, xlab = "Rank of p-value rank for pretreatment variables \n (hollow is weighted, solid is unweighted)", ylab = "t- and chi-squared p-values \n (pairwise minimum)", pch = c(19,1), col = "black", scales = list(alternating = 1), par.settings = list(strip.background = list(col=stripBgCol)),#
   	#subst = (as.factor(esDat$whichComp) %in% levels(as.factor(esDat$whichComp))[subst]) & (esDat$tRank <= n.var2), #
   	ylim = c(-.1, 1.1), ..., #
   	   	panel = function(...){#
   	   		panel.xyplot(x=c(1,n.var2), y=c(0,1), col=ltBl, type="l")#
#   		panel.abline(a=0, b=1, col="lightblue")#
   		panel.xyplot(...)#
   		}#
)#
   	}#
   if (plots =="ks" || plots ==5) {  ## ks plot#
   	if(x$estimand =="ATE") pwc <- pairwiseComparison(x, collapse.to = "covariate")#
#
   	esDat <- makePlotDat(x$psList[[1]], whichPlot = 5, subsetStopMeth = subset)#
   	nVar <- length(makePlotDat(x$psList[[1]], whichPlot = 5, subsetStopMeth = 1, yOnly = TRUE, incUnw = FALSE))#
   	effSzList <- effSzListUnw <- matrix(NA, nrow = nVar, ncol = length(x$psList))   	#
   	cnt <- 0#
   	for(k in subset){#
   		cnt <- cnt + 1#
   	for(j in 1:length(x$psList)){	#
	x2 <- x$psList[[j]]#
	effSzList[,j] <- makePlotDat(x2, whichPlot = 5, subsetStopMeth = k, yOnly = TRUE, incUnw = FALSE)#
	effSzListUnw[,j] <- makePlotDat(x2, whichPlot = 5, subsetStopMeth = 1, yOnly = TRUE, incUnw = TRUE)[1:nVar]#
	collapsed <- apply(effSzList, 1, max)#
	if(x$estimand == "ATE") collapsed <- pwc$min.ks.pval[pwc$stop.method == x$stopMethods[k]]#
	collapsedUnw <- apply(effSzListUnw, 1, max)#
	if(x$estimand == "ATE") collapsedUnw <- pwc$min.ks.pval[pwc$stop.method == "unw"]	#
	collRanks <- rank(collapsed, ties.method = "first")#
	esBigHold <- collapsed > collapsedUnw#
	esDat$ksPVal[(1:(2*nVar)) + (cnt-1)*2*nVar] <- c(collapsed, collapsedUnw)#
	esDat$ksRank[(1:(2*nVar)) + (cnt-1)*2*nVar] <- rep(collRanks, 2)#
	}#
	}#
   	if(is.null(subst))	subst <- 1:length(levels(as.factor(esDat$whichComp)))#
   	n.var2 <- max(esDat$ksRank*(!is.na(esDat$ksPVal)), na.rm=TRUE)#
   	pt1 <- xyplot(ksPVal~ksRank|whichComp, groups=weighted, scales = list(alternating = 1), data = esDat,ylim = c(-.1, 1.1), ..., xlab = "Rank of p-value rank for pretreatment variables \n (hollow is weighted, solid is unweighted)", ylab = "KS test p-values", pch = c(19,1), col="black",par.settings = list(strip.background = list(col=stripBgCol)),#
   	subst = (as.factor(esDat$whichComp) %in% levels(as.factor(esDat$whichComp))[subst]) & (esDat$ksRank <= n.var2),#
   	panel = function(...){#
   		panel.xyplot(x=c(1,n.var2), y=c(0,1), col=ltBl, type="l")#
   		panel.xyplot(...)#
   	})#
   	}#
return(pt1)#
	}#
#
}#
#
}
plot.mnps(mnps.AOD, plots = 3)
##require(twang); data(AOD); AOD$crimjust[198:202] <- NA; mnps.AOD <- mnps(treat ~ illact + crimjust + subprob + subdep + white, data = AOD, estimand = "ATT", stop.method = c("ks.max","es.max"), n.trees = 1000, treatATT = 'community')#
plot.mnps <- function(x,plots="optimize", pairwiseMax = TRUE, figureRows = 1, color = TRUE, subset = NULL, ...)#
{#
   # Creates diag.plot plots and sends to current device#
   # x:     ps object #
   # label: Label added to the plot titles#
#
   # extract the propensity scores and weights from the ps object#
   	if(is.null(subset)) subset <- 1:length(x$stopMethods)#
   	ltBl <- ifelse(color, "lightblue","gray80")#
	rdCol <- ifelse(color, "red","black")#
	stripBgCol <- ifelse(color, "#ffe5cc", "transparent")#
	ptSymCol <- ifelse(color, "#0080ff", "black")#
   ifelse(x$estimand == "ATE", noKS <- TRUE, noKS <- FALSE)#
   subst <- whichVar <- pVal <- weighted <- NULL #
   if(length(plots) > 1) stop("The `plots' argument must be of length 1.")#
   if(!(plots %in% c(1,2,3,4,5)) & !(plots %in% c("boxplot","ks","optimize","es","t")))#
   stop("Invalid choice of `plots' argument.")#
   if(plots == 2 | plots == "boxplot"){#
   	boxplot(x, color = color, stop.method = subset, ...)#
   }#
   else{#
   if(!pairwiseMax | plots == "optimize" | plots == 1){#
   nPlot <- x$nFits#
   ptHld <- vector(mode = "list", length = nPlot)#
   for(i in 1:nPlot){#
   	if(x$estimand == "ATT") ptNm <- paste("Balance for", x$levExceptTreatATT[i], "versus unweighted", x$treatATT)#
   	else ptNm <- paste("Balance for", x$treatLev[i], "against others")#
   	ptHld[[i]] <- plot(x$psList[[i]], main = ptNm, plots = plots, noKS = TRUE, color = color, subset=subset, ...)#
   }#
#
#pt1 <- twang:::diag.plot(x, plots, subset = subset, ...)#
figCol <- ceiling(nPlot/figureRows)#
#
if(dev.cur() == 1) dev.new()#
#
curCol <- curRow <- 1#
#
for(i in 1:(nPlot-1)){#
	print(ptHld[[i]], split = c(curCol,curRow,nx = figCol,ny = figureRows), more = TRUE)#
	if(curCol < figCol){#
		curCol <- curCol + 1#
	}#
	else {#
		curCol <- 1#
		curRow <- curRow + 1#
	}#
}#
#
print(ptHld[[nPlot]], split = c(curCol,curRow,nx = figCol,ny = figureRows), more = FALSE)#
#
}#
#
else{  ## if pairwiseMax and plots == something other than optimize#
#
n.tp <- length(x$psList[[1]]$desc)#
n.psFits <- length(x$psList)#
#   	return(esDat)   #
   if (plots == "es" || plots == 3)	{ ## es plot#
   	esDat <- makePlotDat(x$psList[[1]], whichPlot = 3, subsetStopMeth = subset)#
   	nVar <- length(makePlotDat(x$psList[[1]], whichPlot = 3, subsetStopMeth = 1, yOnly = TRUE, incUnw = FALSE)$pVal)#
   	effSzList <- effSzListUnw <- pValListUnw <- pValList <- matrix(NA, nrow = nVar, ncol = length(x$psList))#
   	pwc <- bal.table(x, collapse.to = "covariate")#
   	#if(x$estimand == "ATE"){#
   	#	pwc <- pairwiseComparison(x, collapse.to = "covariate")	#
   	#	}#
   	cnt <- 0#
   	for(k in subset){#
   		cnt <- cnt + 1#
   		#if(x$estimand == "ATT"){#
   		#for(j in 1:length(x$psList)){	#
			#x2 <- x$psList[[j]]#
			#effSzList[,j] <- makePlotDat(x2, whichPlot = 3, subsetStopMeth = k, yOnly = TRUE, incUnw = FALSE)$effectSize#
			#effSzListUnw[,j] <- makePlotDat(x2, whichPlot = 3, subsetStopMeth = 1, yOnly = TRUE, incUnw = TRUE)$effectSize[(nVar + 1):(2*nVar)]#
			#pValListUnw[,j] <- makePlotDat(x2, whichPlot = 3, subsetStopMeth = 1, yOnly = TRUE, incUnw = TRUE)$pVal[(nVar + 1):(2*nVar)]#
			#pValList[,j] <- makePlotDat(x2, whichPlot = 3, subsetStopMeth = k, yOnly = TRUE, incUnw = FALSE)$pVal	#
			#}#
			#effSzList <- abs(effSzList)#
			#effSzListUnw <- abs(effSzListUnw)#
			#collapsed <- apply(effSzList, 1, max)#
			#collapsedUnw <- apply(effSzListUnw, 1, max)#
			#collapsedP <- apply(pValList < .05, 1, max)#
			#collapsedUnwP <- apply(pValListUnw < .05, 1, max)	#
			collapsed <- pwc$max.std.eff.sz[pwc$stop.method == x$stopMethods[k]]#
   			collapsedP <- pwc$min.p[pwc$stop.method == x$stopMethods[k]] < .05#
#   			collapsedUnw <- rep(pwc$max.std.eff.sz[pwc$stop.method == "unw"], length(subset))#
#   			collapsedUnwP <- rep(pwc$min.p[pwc$stop.method == "unw"], length(subset)) < .05		#
   			collapsedUnw <- pwc$max.std.eff.sz[pwc$stop.method == "unw"]#
   			collapsedUnwP <- pwc$min.p[pwc$stop.method == "unw"] < .05		#
		#}#
		esBigHold <- collapsed > collapsedUnw#
		esDat$effectSize[(1:(2*nVar)) + (cnt-1)*2*nVar] <- c(collapsed, collapsedUnw)#
		esDat$pVal[(1:(2*nVar)) + (cnt-1)*2*nVar] <- c(collapsedP, collapsedUnwP)#
		esDat$esBig[(1:(2*nVar)) + (cnt-1)*2*nVar] <- rep(esBigHold, 2)#
	}#
   	yMax <- min(3,max(esDat[,1])) + .05	#
   	if(max(esDat[,1], na.rm=TRUE) > 3)#
   	warning("Some effect sizes are larger than 3 and may not have been plotted.\n")	#
    nullPlot <- TRUE#
   	subsetHold <- !esDat$esBig #
   	if(any(subsetHold)){#
   		esDatTmp <- esDat#
   		esDatTmp$effectSize[!subsetHold] <- NA#
   		pt1.1 <- xyplot(effectSize ~ weighted | whichComp, groups = whichVar, data = esDatTmp, scales = list(alternating = 1),#
   			ylim = c(-.05, yMax), type = "l", col = ltBl, as.table = TRUE,#
   			ylab = "Absolute standardized difference \n (maximum pairwise)", xlab = NULL, par.settings = list(strip.background = list(col=stripBgCol)),#
   			panel = function(...){#
   				panel.abline(h=c(.2,.5,.8), col="gray80")#
   				panel.xyplot(...)#
		   	})#
   		nullPlot <- FALSE#
   		currPt <- pt1.1#
   	}#
   	subsetHold <- esDat$esBig #
   	if(any(subsetHold)){#
   		esDatTmp <- esDat#
   		esDatTmp$effectSize[!subsetHold] <- NA#
   		pt1.2 <- xyplot(effectSize ~ weighted | whichComp, groups = whichVar, #
   			data = esDatTmp, ylab = "Absolute standard difference", xlab = NULL, as.table = TRUE,#
   			ylim = c(-.05, yMax), type = "l", col = rdCol, par.settings = list(strip.background = list(col=stripBgCol)),#
   			lwd = 2, ...)#
   		if(!nullPlot){#
   			currPt <- currPt + pt1.2#
   		}#
   		else{#
   			currPt <- pt1.2#
   			nullPlot <- FALSE#
   		}#
   	}#
   	if(all(esDat$pVal >= .05)) pchHold <- 19#
   	else if(all(esDat$pVal < .05)) pchHold <- 1#
   	else pchHold <- c(19,1)#
   	pt2 <- xyplot(effectSize ~ weighted | whichComp, groups = (pVal < 0.05), data = esDat,#
   	ylab = "Absolute standard difference", xlab = NULL, as.table = TRUE, #
   	ylim = c(-.05, yMax), type = "p", col = rdCol, pch = pchHold,par.settings = list(strip.background = list(col=stripBgCol)),#
   	...)#
   	if(!nullPlot) currPt <- currPt + pt2#
   	else currPt <- pt2#
   	return(currPt)#
   	}#
   if (plots == "t" || plots == 4) { ## t p-values plot#
#
   	esDat <- makePlotDat(x$psList[[1]], whichPlot = 4, subsetStopMeth = subset)#
   	nVar <- length(makePlotDat(x$psList[[1]], whichPlot = 4, subsetStopMeth = 1, yOnly = TRUE, incUnw = FALSE))#
   	effSzList <- effSzListUnw <- matrix(NA, nrow = nVar, ncol = length(x$psList))   	#
   	pwc <- bal.table(x, collapse.to = "covariate")#
   	cnt <- 0#
   	for(k in subset){#
   		cnt <- cnt + 1#
   	for(j in 1:length(x$psList)){	#
		collapsed <- pwc$min.p[pwc$stop.method == x$stopMethods[k]]	#
		collapsedUnw <- pwc$min.p[pwc$stop.method == 'unw']		#
		collRanks <- rank(collapsed, ties.method = "first")#
		esBigHold <- collapsed > collapsedUnw#
		esDat$tPVal[(1:(2*nVar)) + (cnt - 1)*2*nVar] <- c(collapsed, collapsedUnw)#
		esDat$tRank[(1:(2*nVar)) + (cnt - 1)*2*nVar] <- rep(collRanks, 2)#
	}#
	}#
   	   #	if(is.null(subst))	subst <- 1:length(levels(as.factor(esDat$whichComp)))#
   	n.var2 <- max(esDat$tRank * (!is.na(esDat$tPVal)), na.rm=TRUE)#
   	pt1 <- xyplot(tPVal~tRank|whichComp, groups = weighted, data=esDat, xlab = "Rank of p-value rank for pretreatment variables \n (hollow is weighted, solid is unweighted)", ylab = "t- and chi-squared p-values \n (pairwise minimum)", pch = c(19,1), col = "black", scales = list(alternating = 1), par.settings = list(strip.background = list(col=stripBgCol)),#
   	#subst = (as.factor(esDat$whichComp) %in% levels(as.factor(esDat$whichComp))[subst]) & (esDat$tRank <= n.var2), #
   	ylim = c(-.1, 1.1), ..., #
   	   	panel = function(...){#
   	   		panel.xyplot(x=c(1,n.var2), y=c(0,1), col=ltBl, type="l")#
#   		panel.abline(a=0, b=1, col="lightblue")#
   		panel.xyplot(...)#
   		}#
)#
   	}#
   if (plots =="ks" || plots ==5) {  ## ks plot#
   	if(x$estimand =="ATE") pwc <- pairwiseComparison(x, collapse.to = "covariate")#
#
   	esDat <- makePlotDat(x$psList[[1]], whichPlot = 5, subsetStopMeth = subset)#
   	nVar <- length(makePlotDat(x$psList[[1]], whichPlot = 5, subsetStopMeth = 1, yOnly = TRUE, incUnw = FALSE))#
   	effSzList <- effSzListUnw <- matrix(NA, nrow = nVar, ncol = length(x$psList))   	#
   	cnt <- 0#
   	for(k in subset){#
   		cnt <- cnt + 1#
   	for(j in 1:length(x$psList)){	#
	x2 <- x$psList[[j]]#
	effSzList[,j] <- makePlotDat(x2, whichPlot = 5, subsetStopMeth = k, yOnly = TRUE, incUnw = FALSE)#
	effSzListUnw[,j] <- makePlotDat(x2, whichPlot = 5, subsetStopMeth = 1, yOnly = TRUE, incUnw = TRUE)[1:nVar]#
	collapsed <- apply(effSzList, 1, max)#
	if(x$estimand == "ATE") collapsed <- pwc$min.ks.pval[pwc$stop.method == x$stopMethods[k]]#
	collapsedUnw <- apply(effSzListUnw, 1, max)#
	if(x$estimand == "ATE") collapsedUnw <- pwc$min.ks.pval[pwc$stop.method == "unw"]	#
	collRanks <- rank(collapsed, ties.method = "first")#
	esBigHold <- collapsed > collapsedUnw#
	esDat$ksPVal[(1:(2*nVar)) + (cnt-1)*2*nVar] <- c(collapsed, collapsedUnw)#
	esDat$ksRank[(1:(2*nVar)) + (cnt-1)*2*nVar] <- rep(collRanks, 2)#
	}#
	}#
   	if(is.null(subst))	subst <- 1:length(levels(as.factor(esDat$whichComp)))#
   	n.var2 <- max(esDat$ksRank*(!is.na(esDat$ksPVal)), na.rm=TRUE)#
   	pt1 <- xyplot(ksPVal~ksRank|whichComp, groups=weighted, scales = list(alternating = 1), data = esDat,ylim = c(-.1, 1.1), ..., xlab = "Rank of p-value rank for pretreatment variables \n (hollow is weighted, solid is unweighted)", ylab = "KS test p-values", pch = c(19,1), col="black",par.settings = list(strip.background = list(col=stripBgCol)),#
   	subst = (as.factor(esDat$whichComp) %in% levels(as.factor(esDat$whichComp))[subst]) & (esDat$ksRank <= n.var2),#
   	panel = function(...){#
   		panel.xyplot(x=c(1,n.var2), y=c(0,1), col=ltBl, type="l")#
   		panel.xyplot(...)#
   	})#
   	}#
return(pt1)#
	}#
#
}#
#
}
plot.mnps(mnps.AOD, plots = 3)
q()
require(twang); data(AOD); AOD$crimjust[198:202] <- NA; mnps.AOD <- mnps(treat ~ illact + crimjust + subprob + subdep + white, data = AOD, estimand = "ATT", stop.method = c("ks.max","es.max"), n.trees = 1000, treatATT = 'community')
bal.table(mnps.AOD)
bal.table
summary.mnps
twang:::summary.mnps
ls()
pairwiseComp(mnps.AOD)
twang:::pairwiseComp(mnps.AOD)
summary(mnps.AOD)
require(twang); data(AOD); AOD$crimjust[198:202] <- NA; mnps.AOD.ATE <- mnps(treat ~ illact + crimjust + subprob + subdep + white, data = AOD, estimand = "ATE", stop.method = c("ks.max","es.max"), n.trees = 1000)
summary(mnps.AOD.ATE)
summary(mnps.AOD)
rm(list=ls())
q()
require(twang); data(AOD);
mnps.AOD <- mnps(treat ~ illact + crimjust + subprob + subdep + white, data = AOD, estimand = "ATT", stop.method = c("ks.max","es.max"), n.trees = 1000, treatATT = 'community')
summary(mnps.AOD)
str(summary(mnps.AOD))
mnps.AOD$summaryList[[1]]
summary(mnps.AOD)$summaryList[[1]]
summary(mnps.AOD)
str(mnps.AOD)
names(mnps.AOD)
summary(mnps.AOD$treatVar)
sum(mnps.AOD$treatVar == treatATT)
sum(mnps.AOD$treatVar == mnps.AODtreatATT)
sum(mnps.AOD$treatVar == mnps.AOD$treatATT)
str(summary(mnps.AOD))
mnps.AOD$summarList[[1]]
summary(mnps.AOD)$summaryList[[1]]
row.names(summary(mnps.AOD)$summaryList[[1]])
twang:::print.summary.mnps
q()
require(twang); data(AOD)
mnps.AOD <- mnps(treat ~ illact + crimjust + subprob + subdep + white, data = AOD, estimand = "ATT", stop.method = c("ks.max","es.max"), n.trees = 1000, treatATT = 'community')
bal.table(mnps.AOD)
debug(bal.table)
bal.table(mnps.AOD)
balTabList
subset.var
es.cutoff
ks.cutoff
p.cutoff
ks.p.cutoff
balTabList
balTabList
require(foreign)
Q
rm(list=ls())
require(foreign)
dt <- read.dta("~/Desktop/EMID/partiallyOrderedAnalysis/stataApprop/sub09_analytic04012014.dta")
dt <- read.dta("~/Desktop/EMID/partiallyOrderedAnalysis/stataApprop/sub09_analytic04012014small.dta")
head(dt)
require(lme4)
install.packages("lme4")
install.packages("lme4")
chooseCRANmirror()
chooseCRANmirror()
install.packages("lme4")
require(lme4)
head(dt)
table(dt$subconvener)
subDt <- subset(dt, subconvener == "Cornell")
head(subDt)
head(unique(subDt$clinicianID))
length(unique(subDt$clinicianID))
subDt <- subDt[order(subDt$clinicianID),]
head(subDt)
hldRes <- data.frame(clinID = sort(subDt$clinicianID), numOrders = NA)
head(hldRes)
hldRes <- data.frame(clinID = sort(unique(subDt$clinicianID)), numOrders = NA)
head(hldRes)
for(i in 1:nrow(hldRes)) numOrders[i] <- sum(subDt$clinId == hldRes[i])
for(i in 1:nrow(hldRes)) numOrders[i] <- sum(subDt$clinId == hldRes$clinID[i])
for(i in 1:nrow(hldRes)) hldRes$numOrders[i] <- sum(subDt$clinId == hldRes$clinID[i])
head(hldRes)
for(i in 1:nrow(hldRes)) hldRes$numOrders[i] <- sum(subDt$clinicianID == hldRes$clinID[i])
head(hldRes)
rm(list=ls())
load("/Users/burgette/Desktop/rbrvs/timeEsts04162014/sparcsPrunedAnalyticOneCode04162014-NoMissAneType.RData")
ls()
head(smallSpAny)
smallSpAny$proc1 <- as.character(smallSpAny$proc1)#
smallSpAny$proc1[smallSpAny$proc1 == "G0104"] <- "45330"#
smallSpAny$proc1[smallSpAny$proc1 == "G0105"] <- "45378"#
smallSpAny$proc1[smallSpAny$proc1 == "G0121"] <- "45378"#
smallSpAny$proc1[smallSpAny$proc1 == "G0268"] <- "69210"
smallSpAny$proc1 <- as.numeric(smallSpAny$proc1)
spc <- with(smallSpAny, data.frame(time = optime_mins, ane = as.numeric(anemeth %in% c("20","30")), inpt = 0, spcs = 1, hcpcs = proc1))
head(spcs)
head(spc)
allDt <- spc
masterList <- read.csv("~/Desktop/rbrvs/timeEsts09042014/surgical_master_list09042014.csv")
masterList <- subset(masterList, core == 1)
masterList$Median_Intra_Service_Time2014[is.na(masterList$Median_Intra_Service_Time2014)] <- masterList$Median_Intra_Service_Time2013[is.na(masterList$Median_Intra_Service_Time2014)]
times2012 <- read.csv("~/Desktop/rbrvs/timeEsts08212014/PhysTime_FR2012_Public.csv")
times2012 <- times2012[,c("HCPCS","IntraService2012")]
masterList <- merge(masterList, times2012, all.x=TRUE)
masterList$Median_Intra_Service_Time2014[is.na(masterList$Median_Intra_Service_Time2014)] <- masterList$IntraService2012[is.na(masterList$Median_Intra_Service_Time2014)]
masterSmall <- masterList[,c("HCPCS","l1","Median_Intra_Service_Time2014","core","flag_sedate")]
masterSmall$HCPCS <- as.character(masterSmall$HCPCS)
names(masterSmall)[1] <- "hcpcs"
rm(masterList)
ls()
head(masterSmall)
summarh(masterSmall$flag_sedate)
summary(masterSmall$flag_sedate)
allDt <- merge(allDt, masterSmall)
head(allDt)
118 * 1.01
allDt$time <- newSilber07312014(allDt$time)
newSilber07312014 <- function(t){#
#
x <- c(0, 30, 70, 36 * 60)#
#
y <- c(0, 30 * .5, 70 * .86667 - 18, 36 * 60 * .86667 - 18)#
return(approx(x=x,y=y, xout = t)$y)#
}
allDt$time <- newSilber07312014(allDt$time)
.91057 * 300
head(allDt)
require(lme4)
summary(allDt$core)
lmer(log(time) ~ log(Median_Intra_Service_Time2014) + ane * flag_sedate + (1|hcpcs), data = allDt)
ft1 <- lmer(log(time) ~ log(Median_Intra_Service_Time2014) + ane * flag_sedate + (1|hcpcs), data = allDt)
summary(ft1)
table(allDt$flag_sedate)
table(allDt$flag_sedate, allDt$ane)
ft1 <- lmer(log(time) ~ ane * flag_sedate + (1|hcpcs), data = allDt)
summary(ft1)
q()
